// Package services provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package services

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/datum-cloud/datum-os/pkg/echox"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// GoogleProtobufAny Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// Type The type of the serialized message.
	Type                 *string                `json:"@type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ListVendorsResponse defines model for ListVendorsResponse.
type ListVendorsResponse struct {
	NextPageToken *string   `json:"nextPageToken,omitempty"`
	Vendors       *[]Vendor `json:"vendors,omitempty"`
}

// PostalAddress Represents a postal address, e.g. for postal delivery or payments addresses.
//
//	Given a postal address, a postal service can deliver items to a premise, P.O.
//	Box or similar.
//	It is not intended to model geographical locations (roads, towns,
//	mountains).
//
//	In typical usage an address would be created via user input or from importing
//	existing data, depending on the type of process.
//
//	Advice on address input / editing:
//	 - Use an i18n-ready address widget such as
//	   https://github.com/google/libaddressinput)
//	- Users should not be presented with UI elements for input or editing of
//	  fields outside countries where that field is used.
//
//	For more guidance on how to use this schema, please see:
//	https://support.google.com/business/answer/6397478
type PostalAddress struct {
	// AddressLines Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may
	//  sometimes contain multiple values in a single field (e.g.
	//  "Austin, TX"), it is important that the line order is clear. The order of
	//  address lines should be "envelope order" for the country/region of the
	//  address. In places where this can vary (e.g. Japan), address_language is
	//  used to make it explicit (e.g. "ja" for large-to-small ordering and
	//  "ja-Latn" or "en" for small-to-large). This way, the most specific line of
	//  an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists
	//  of a region_code with all remaining information placed in the
	//  address_lines. It would be possible to format such an address very
	//  approximately without geocoding, but no semantic reasoning could be
	//  made about any of the address components until it was at least
	//  partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and
	//  then geocoding is the recommended way to handle completely unstructured
	//  addresses (as opposed to guessing which parts of the address should be
	//  localities or administrative areas).
	AddressLines *[]string `json:"addressLines,omitempty"`

	// AdministrativeArea Optional. Highest administrative subdivision which is used for postal
	//  addresses of a country or region.
	//  For example, this can be a state, a province, an oblast, or a prefecture.
	//  Specifically, for Spain this is the province and not the autonomous
	//  community (e.g. "Barcelona" and not "Catalonia").
	//  Many countries don't use an administrative area in postal addresses. E.g.
	//  in Switzerland this should be left unpopulated.
	AdministrativeArea *string `json:"administrativeArea,omitempty"`

	// LanguageCode Optional. BCP-47 language code of the contents of this address (if
	//  known). This is often the UI language of the input form or is expected
	//  to match one of the languages used in the address' country/region, or their
	//  transliterated equivalents.
	//  This can affect formatting in certain countries, but is not critical
	//  to the correctness of the data and will never affect any validation or
	//  other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a
	//  possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `json:"languageCode,omitempty"`

	// Locality Optional. Generally refers to the city/town portion of the address.
	//  Examples: US city, IT comune, UK post town.
	//  In regions of the world where localities are not well defined or do not fit
	//  into this structure well, leave locality empty and use address_lines.
	Locality *string `json:"locality,omitempty"`

	// Organization Optional. The name of the organization at the address.
	Organization *string `json:"organization,omitempty"`

	// PostalCode Optional. Postal code of the address. Not all countries use or require
	//  postal codes to be present, but where they are used, they may trigger
	//  additional validation with other parts of the address (e.g. state/zip
	//  validation in the U.S.A.).
	PostalCode *string `json:"postalCode,omitempty"`

	// Recipients Optional. The recipient at the address.
	//  This field may, under certain circumstances, contain multiline information.
	//  For example, it might contain "care of" information.
	Recipients *[]string `json:"recipients,omitempty"`

	// RegionCode Required. CLDR region code of the country/region of the address. This
	//  is never inferred and it is up to the user to ensure the value is
	//  correct. See http://cldr.unicode.org/ and
	//  http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
	//  for details. Example: "CH" for Switzerland.
	RegionCode *string `json:"regionCode,omitempty"`

	// Revision The schema revision of the `PostalAddress`. This must be set to 0, which is
	//  the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	Revision *int32 `json:"revision,omitempty"`

	// SortingCode Optional. Additional, country-specific, sorting code. This is not used
	//  in most regions. Where it is used, the value is either a string like
	//  "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
	//  alone, representing the "sector code" (Jamaica), "delivery area indicator"
	//  (Malawi) or "post office indicator" (e.g. CÃ´te d'Ivoire).
	SortingCode *string `json:"sortingCode,omitempty"`

	// Sublocality Optional. Sublocality of the address.
	//  For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `json:"sublocality,omitempty"`
}

// Status The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// Code The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details.  There is a common set of message types for APIs to use.
	Details *[]GoogleProtobufAny `json:"details,omitempty"`

	// Message A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message *string `json:"message,omitempty"`
}

// Vendor Vendor is a resource representing a Vendor.
type Vendor struct {
	// Annotations Annotations is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Vendor is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Vendor that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to enable platform features which identify
	//  Vendors via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Vendor.
	Name *string `json:"name,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Vendor.
	Reconciling *bool `json:"reconciling,omitempty"`

	// Spec The specification of the Vendor.
	Spec VendorSpec `json:"spec"`

	// Uid Server assigned unique identifier for the Vendor. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Vendor is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// VendorId The resource ID of this Vendor within its parent resource.
	VendorId *string `json:"vendorId,omitempty"`
}

// VendorSpec VendorSpec is the specification of a Vendor.
type VendorSpec struct {
	// Address The physical address of the corporation.
	Address *PostalAddress `json:"address,omitempty"`

	// CompanyName The name of the company.
	CompanyName string `json:"companyName"`

	// CorporationDba The DBA (Doing Business As) name of the corporation.
	CorporationDba string `json:"corporationDba"`

	// CorporationType The type of corporation (e.g. LLC, S-Corp, C-Corp).
	CorporationType string `json:"corporationType"`

	// Description The description of the corporation and the services it provides.
	Description string `json:"description"`

	// TaxIdentifier The tax identifier of the corporation (e.g. 123456789).
	TaxIdentifier string `json:"taxIdentifier"`
}

// VendorsListVendorsParams defines parameters for VendorsListVendors.
type VendorsListVendorsParams struct {
	Parent    *string `form:"parent,omitempty" json:"parent,omitempty"`
	PageSize  *int32  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	Filter    *string `form:"filter,omitempty" json:"filter,omitempty"`
	OrderBy   *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// VendorsCreateVendorParams defines parameters for VendorsCreateVendor.
type VendorsCreateVendorParams struct {
	Parent       *string `form:"parent,omitempty" json:"parent,omitempty"`
	VendorId     *string `form:"vendorId,omitempty" json:"vendorId,omitempty"`
	ValidateOnly *bool   `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsUpdateVendorParams defines parameters for VendorsUpdateVendor.
type VendorsUpdateVendorParams struct {
	// VendorName The resource name of this Vendor.
	VendorName *string `form:"vendor.name,omitempty" json:"vendor.name,omitempty"`

	// VendorVendorId The resource ID of this Vendor within its parent resource.
	VendorVendorId *string `form:"vendor.vendorId,omitempty" json:"vendor.vendorId,omitempty"`

	// VendorUid Server assigned unique identifier for the Vendor. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	VendorUid *string `form:"vendor.uid,omitempty" json:"vendor.uid,omitempty"`

	// VendorDisplayName Human-readable display name of this Vendor that you can modify.
	//  The maximum length is 63 characters.
	VendorDisplayName *string `form:"vendor.displayName,omitempty" json:"vendor.displayName,omitempty"`

	// VendorCreateTime Output only. The time when the Vendor is created.
	VendorCreateTime *time.Time `form:"vendor.createTime,omitempty" json:"vendor.createTime,omitempty"`

	// VendorUpdateTime Output only. The last time that the Vendor is updated.
	VendorUpdateTime *time.Time `form:"vendor.updateTime,omitempty" json:"vendor.updateTime,omitempty"`

	// VendorDeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	VendorDeleteTime *time.Time `form:"vendor.deleteTime,omitempty" json:"vendor.deleteTime,omitempty"`

	// VendorReconciling Output only. If set, there are currently changes in flight to the Vendor.
	VendorReconciling *bool `form:"vendor.reconciling,omitempty" json:"vendor.reconciling,omitempty"`

	// VendorEtag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	VendorEtag *string `form:"vendor.etag,omitempty" json:"vendor.etag,omitempty"`

	// VendorSpecCompanyName The name of the company.
	VendorSpecCompanyName *string `form:"vendor.spec.companyName,omitempty" json:"vendor.spec.companyName,omitempty"`

	// VendorSpecCorporationType The type of corporation (e.g. LLC, S-Corp, C-Corp).
	VendorSpecCorporationType *string `form:"vendor.spec.corporationType,omitempty" json:"vendor.spec.corporationType,omitempty"`

	// VendorSpecCorporationDba The DBA (Doing Business As) name of the corporation.
	VendorSpecCorporationDba *string `form:"vendor.spec.corporationDba,omitempty" json:"vendor.spec.corporationDba,omitempty"`

	// VendorSpecDescription The description of the corporation and the services it provides.
	VendorSpecDescription *string `form:"vendor.spec.description,omitempty" json:"vendor.spec.description,omitempty"`

	// VendorSpecTaxIdentifier The tax identifier of the corporation (e.g. 123456789).
	VendorSpecTaxIdentifier *string `form:"vendor.spec.taxIdentifier,omitempty" json:"vendor.spec.taxIdentifier,omitempty"`

	// VendorSpecAddressRevision The schema revision of the `PostalAddress`. This must be set to 0, which is
	//  the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	VendorSpecAddressRevision *int32 `form:"vendor.spec.address.revision,omitempty" json:"vendor.spec.address.revision,omitempty"`

	// VendorSpecAddressRegionCode Required. CLDR region code of the country/region of the address. This
	//  is never inferred and it is up to the user to ensure the value is
	//  correct. See http://cldr.unicode.org/ and
	//  http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
	//  for details. Example: "CH" for Switzerland.
	VendorSpecAddressRegionCode *string `form:"vendor.spec.address.regionCode,omitempty" json:"vendor.spec.address.regionCode,omitempty"`

	// VendorSpecAddressLanguageCode Optional. BCP-47 language code of the contents of this address (if
	//  known). This is often the UI language of the input form or is expected
	//  to match one of the languages used in the address' country/region, or their
	//  transliterated equivalents.
	//  This can affect formatting in certain countries, but is not critical
	//  to the correctness of the data and will never affect any validation or
	//  other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a
	//  possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	VendorSpecAddressLanguageCode *string `form:"vendor.spec.address.languageCode,omitempty" json:"vendor.spec.address.languageCode,omitempty"`

	// VendorSpecAddressPostalCode Optional. Postal code of the address. Not all countries use or require
	//  postal codes to be present, but where they are used, they may trigger
	//  additional validation with other parts of the address (e.g. state/zip
	//  validation in the U.S.A.).
	VendorSpecAddressPostalCode *string `form:"vendor.spec.address.postalCode,omitempty" json:"vendor.spec.address.postalCode,omitempty"`

	// VendorSpecAddressSortingCode Optional. Additional, country-specific, sorting code. This is not used
	//  in most regions. Where it is used, the value is either a string like
	//  "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
	//  alone, representing the "sector code" (Jamaica), "delivery area indicator"
	//  (Malawi) or "post office indicator" (e.g. CÃ´te d'Ivoire).
	VendorSpecAddressSortingCode *string `form:"vendor.spec.address.sortingCode,omitempty" json:"vendor.spec.address.sortingCode,omitempty"`

	// VendorSpecAddressAdministrativeArea Optional. Highest administrative subdivision which is used for postal
	//  addresses of a country or region.
	//  For example, this can be a state, a province, an oblast, or a prefecture.
	//  Specifically, for Spain this is the province and not the autonomous
	//  community (e.g. "Barcelona" and not "Catalonia").
	//  Many countries don't use an administrative area in postal addresses. E.g.
	//  in Switzerland this should be left unpopulated.
	VendorSpecAddressAdministrativeArea *string `form:"vendor.spec.address.administrativeArea,omitempty" json:"vendor.spec.address.administrativeArea,omitempty"`

	// VendorSpecAddressLocality Optional. Generally refers to the city/town portion of the address.
	//  Examples: US city, IT comune, UK post town.
	//  In regions of the world where localities are not well defined or do not fit
	//  into this structure well, leave locality empty and use address_lines.
	VendorSpecAddressLocality *string `form:"vendor.spec.address.locality,omitempty" json:"vendor.spec.address.locality,omitempty"`

	// VendorSpecAddressSublocality Optional. Sublocality of the address.
	//  For example, this can be neighborhoods, boroughs, districts.
	VendorSpecAddressSublocality *string `form:"vendor.spec.address.sublocality,omitempty" json:"vendor.spec.address.sublocality,omitempty"`

	// VendorSpecAddressAddressLines Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may
	//  sometimes contain multiple values in a single field (e.g.
	//  "Austin, TX"), it is important that the line order is clear. The order of
	//  address lines should be "envelope order" for the country/region of the
	//  address. In places where this can vary (e.g. Japan), address_language is
	//  used to make it explicit (e.g. "ja" for large-to-small ordering and
	//  "ja-Latn" or "en" for small-to-large). This way, the most specific line of
	//  an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists
	//  of a region_code with all remaining information placed in the
	//  address_lines. It would be possible to format such an address very
	//  approximately without geocoding, but no semantic reasoning could be
	//  made about any of the address components until it was at least
	//  partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and
	//  then geocoding is the recommended way to handle completely unstructured
	//  addresses (as opposed to guessing which parts of the address should be
	//  localities or administrative areas).
	VendorSpecAddressAddressLines *[]string `form:"vendor.spec.address.addressLines,omitempty" json:"vendor.spec.address.addressLines,omitempty"`

	// VendorSpecAddressRecipients Optional. The recipient at the address.
	//  This field may, under certain circumstances, contain multiline information.
	//  For example, it might contain "care of" information.
	VendorSpecAddressRecipients *[]string `form:"vendor.spec.address.recipients,omitempty" json:"vendor.spec.address.recipients,omitempty"`

	// VendorSpecAddressOrganization Optional. The name of the organization at the address.
	VendorSpecAddressOrganization *string `form:"vendor.spec.address.organization,omitempty" json:"vendor.spec.address.organization,omitempty"`
	UpdateMask                    *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`
}

// VendorsCreateVendorJSONRequestBody defines body for VendorsCreateVendor for application/json ContentType.
type VendorsCreateVendorJSONRequestBody = Vendor

// Getter for additional properties for GoogleProtobufAny. Returns the specified
// element and whether it was found
func (a GoogleProtobufAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufAny
func (a *GoogleProtobufAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a *GoogleProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v1alpha/vendors)
	VendorsListVendors(ctx echox.Context, params VendorsListVendorsParams) error

	// (POST /v1alpha/vendors)
	VendorsCreateVendor(ctx echox.Context, params VendorsCreateVendorParams) error

	// (DELETE /v1alpha/vendors/{vendor})
	VendorsDeleteVendor(ctx echox.Context, vendor string) error

	// (GET /v1alpha/vendors/{vendor})
	VendorsGetVendor(ctx echox.Context, vendor string) error

	// (PATCH /v1alpha/vendors/{vendor})
	VendorsUpdateVendor(ctx echox.Context, vendor string, params VendorsUpdateVendorParams) error
}

// ServerInterfaceWrapper converts datum echox contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// VendorsListVendors converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsListVendors(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsListVendorsParams
	// ------------- Optional query parameter "parent" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent", ctx.QueryParams(), &params.Parent)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsListVendors(ctx, params)
	return err
}

// VendorsCreateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsCreateVendor(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsCreateVendorParams
	// ------------- Optional query parameter "parent" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent", ctx.QueryParams(), &params.Parent)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent: %s", err))
	}

	// ------------- Optional query parameter "vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendorId", ctx.QueryParams(), &params.VendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendorId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsCreateVendor(ctx, params)
	return err
}

// VendorsDeleteVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsDeleteVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsDeleteVendor(ctx, vendor)
	return err
}

// VendorsGetVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsGetVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsGetVendor(ctx, vendor)
	return err
}

// VendorsUpdateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsUpdateVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsUpdateVendorParams
	// ------------- Optional query parameter "vendor.name" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.name", ctx.QueryParams(), &params.VendorName)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.name: %s", err))
	}

	// ------------- Optional query parameter "vendor.vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.vendorId", ctx.QueryParams(), &params.VendorVendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.vendorId: %s", err))
	}

	// ------------- Optional query parameter "vendor.uid" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.uid", ctx.QueryParams(), &params.VendorUid)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.uid: %s", err))
	}

	// ------------- Optional query parameter "vendor.displayName" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.displayName", ctx.QueryParams(), &params.VendorDisplayName)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.displayName: %s", err))
	}

	// ------------- Optional query parameter "vendor.createTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.createTime", ctx.QueryParams(), &params.VendorCreateTime)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.createTime: %s", err))
	}

	// ------------- Optional query parameter "vendor.updateTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.updateTime", ctx.QueryParams(), &params.VendorUpdateTime)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.updateTime: %s", err))
	}

	// ------------- Optional query parameter "vendor.deleteTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.deleteTime", ctx.QueryParams(), &params.VendorDeleteTime)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.deleteTime: %s", err))
	}

	// ------------- Optional query parameter "vendor.reconciling" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.reconciling", ctx.QueryParams(), &params.VendorReconciling)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.reconciling: %s", err))
	}

	// ------------- Optional query parameter "vendor.etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.etag", ctx.QueryParams(), &params.VendorEtag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.etag: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.companyName" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.companyName", ctx.QueryParams(), &params.VendorSpecCompanyName)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.companyName: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.corporationType" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.corporationType", ctx.QueryParams(), &params.VendorSpecCorporationType)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.corporationType: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.corporationDba" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.corporationDba", ctx.QueryParams(), &params.VendorSpecCorporationDba)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.corporationDba: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.description" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.description", ctx.QueryParams(), &params.VendorSpecDescription)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.description: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.taxIdentifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.taxIdentifier", ctx.QueryParams(), &params.VendorSpecTaxIdentifier)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.taxIdentifier: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.revision" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.revision", ctx.QueryParams(), &params.VendorSpecAddressRevision)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.revision: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.regionCode" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.regionCode", ctx.QueryParams(), &params.VendorSpecAddressRegionCode)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.regionCode: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.languageCode" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.languageCode", ctx.QueryParams(), &params.VendorSpecAddressLanguageCode)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.languageCode: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.postalCode" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.postalCode", ctx.QueryParams(), &params.VendorSpecAddressPostalCode)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.postalCode: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.sortingCode" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.sortingCode", ctx.QueryParams(), &params.VendorSpecAddressSortingCode)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.sortingCode: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.administrativeArea" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.administrativeArea", ctx.QueryParams(), &params.VendorSpecAddressAdministrativeArea)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.administrativeArea: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.locality" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.locality", ctx.QueryParams(), &params.VendorSpecAddressLocality)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.locality: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.sublocality" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.sublocality", ctx.QueryParams(), &params.VendorSpecAddressSublocality)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.sublocality: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.addressLines" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.addressLines", ctx.QueryParams(), &params.VendorSpecAddressAddressLines)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.addressLines: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.recipients" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.recipients", ctx.QueryParams(), &params.VendorSpecAddressRecipients)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.recipients: %s", err))
	}

	// ------------- Optional query parameter "vendor.spec.address.organization" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.spec.address.organization", ctx.QueryParams(), &params.VendorSpecAddressOrganization)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.spec.address.organization: %s", err))
	}

	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsUpdateVendor(ctx, vendor, params)
	return err
}

// This is a simple interface which specifies echox.Route addition functions which
// are present on both echox.Echo and echox.Group, since we want to allow using
// either of them for path registration
type EchoxRouter interface {
	CONNECT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	DELETE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	GET(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	HEAD(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	OPTIONS(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PATCH(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	POST(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PUT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	TRACE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoxRouter, si ServerInterface, m ...echox.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoxRouter, si ServerInterface, baseURL string, m ...echox.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1alpha/vendors", wrapper.VendorsListVendors, m...)
	router.POST(baseURL+"/v1alpha/vendors", wrapper.VendorsCreateVendor, m...)
	router.DELETE(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsDeleteVendor, m...)
	router.GET(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsGetVendor, m...)
	router.PATCH(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsUpdateVendor, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"jUnH1hg8GZEdwlERtpd3HNVsfN6V39Jk9uLqrOOKW7YlroZ8MrJq2OQXXz776l++/ubbvxyMJ99DvA8B",
	"sK3dLbtuKuam1Nt+Q8tJvTAcaaVX2HmLoxorIa+3oemWPJ08nXzB/fYKtahkcpQ8mzydPCOPEX7JHjJd",
	"fSFUtRTTwf2vAj39053PEIO0iwxum/E0VpRIqRE7maRVOX9O2kiZBAJJ0nihbyRDuE5vG1nghXyHG2Pv",
	"LHB3zRZuvz1AlIVUHu1DRvIljufNzqFvCEEhY2b9f/n0aegc8AEl81hVqch9019d8KB+vl3cNnY7kEF0",
	"IzL9Pfgon5B9sMVjN2tkvdOwUiyrbS8ZeUBBaGoBl7yJBzm3QpIvSWCsdz8yJruQ+pCx4WAGOXaOjO/y",
	"rwAIzuqfm7z5YOZor2xuUhYF8euPiMDhqp8Q6K7TLW6c/h4+XIdoQjnhraAMRe9toNwORauY9nG6x+gh",
	"ir4JvOSm4R5AK5+U4+8KRd+h/9+o3z+z03BikS1vNdkllzT/o1ZLH1K73x4KJjokeg9d8L7F1w5J9o1N",
	"n0KZvWObtbznDv+w1uAOoYe9y3sJ/5Am8Q45Bv3o0ax62F+4v2z7tjN2Wbdvn3xgAf+g3vYuEPRt+A+8",
	"t/dsCO6QediU3Jmzpv9HOuA7dMGd/ntT/S0Nnx3ruAqzyWYf4Z5r3r9fc7c4NxsZ9xTpAb2qe8gUWin3",
	"FOk9O053ibfZ2LmvBR/UmrpLpM3u0r2F+oSubN2lifZWT3dH7d5NpsdLgx/i0uD+duoubN4vf3r8LcDj",
	"bwE+zm8B9oXuxo9VHgjeP9Md9X31Orjd/0CtPt7G/WNu4+5r0eEl6gea9PFHfZ/Kj/r2BcXIjzofiI0/",
	"+++w9g5Y7UX5B+r5o16i35tLBhf+77WPxz+w8PgHFh7/wMLjH1j4E/2Bhb0j8eAP0ww5dd/fXe4KGp/K",
	"T0z37ld0v6v9GJq6x6+i95V440fZD7jeEprxPwj3dryXxrY7LMP3j2fpd19A6Z/+3uq4/fb6zfV/BwAA",
	"//+flDhgME8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
