// Package services provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package services

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/datum-cloud/datum-os/pkg/echox"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// GoogleProtobufAny Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// Type The type of the serialized message.
	Type                 *string                `json:"@type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ListVendorsResponse defines model for ListVendorsResponse.
type ListVendorsResponse struct {
	NextPageToken *string   `json:"nextPageToken,omitempty"`
	Vendors       *[]Vendor `json:"vendors,omitempty"`
}

// Status The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// Code The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details.  There is a common set of message types for APIs to use.
	Details *[]GoogleProtobufAny `json:"details,omitempty"`

	// Message A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message *string `json:"message,omitempty"`
}

// Vendor defines model for Vendor.
type Vendor struct {
	// Annotations Annotations is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Vendor is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Vendor that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to enable platform features which identify
	//  Vendors via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Vendor.
	Name *string `json:"name,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Vendor.
	Reconciling *bool      `json:"reconciling,omitempty"`
	Spec        VendorSpec `json:"spec"`

	// Uid Server assigned unique identifier for the Vendor. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Vendor is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// VendorId The resource ID of this Vendor within its parent resource.
	VendorId *string `json:"vendorId,omitempty"`
}

// VendorSpec defines model for VendorSpec.
type VendorSpec = map[string]interface{}

// VendorsListVendorsParams defines parameters for VendorsListVendors.
type VendorsListVendorsParams struct {
	Parent    *string `form:"parent,omitempty" json:"parent,omitempty"`
	PageSize  *int32  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
	Filter    *string `form:"filter,omitempty" json:"filter,omitempty"`
	OrderBy   *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// VendorsCreateVendorParams defines parameters for VendorsCreateVendor.
type VendorsCreateVendorParams struct {
	Parent       *string `form:"parent,omitempty" json:"parent,omitempty"`
	VendorId     *string `form:"vendorId,omitempty" json:"vendorId,omitempty"`
	ValidateOnly *bool   `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsUpdateVendorParams defines parameters for VendorsUpdateVendor.
type VendorsUpdateVendorParams struct {
	// VendorName The resource name of this Vendor.
	VendorName *string `form:"vendor.name,omitempty" json:"vendor.name,omitempty"`

	// VendorVendorId The resource ID of this Vendor within its parent resource.
	VendorVendorId *string `form:"vendor.vendorId,omitempty" json:"vendor.vendorId,omitempty"`

	// VendorUid Server assigned unique identifier for the Vendor. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	VendorUid *string `form:"vendor.uid,omitempty" json:"vendor.uid,omitempty"`

	// VendorDisplayName Human-readable display name of this Vendor that you can modify.
	//  The maximum length is 63 characters.
	VendorDisplayName *string `form:"vendor.displayName,omitempty" json:"vendor.displayName,omitempty"`

	// VendorCreateTime Output only. The time when the Vendor is created.
	VendorCreateTime *time.Time `form:"vendor.createTime,omitempty" json:"vendor.createTime,omitempty"`

	// VendorUpdateTime Output only. The last time that the Vendor is updated.
	VendorUpdateTime *time.Time `form:"vendor.updateTime,omitempty" json:"vendor.updateTime,omitempty"`

	// VendorDeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	VendorDeleteTime *time.Time `form:"vendor.deleteTime,omitempty" json:"vendor.deleteTime,omitempty"`

	// VendorReconciling Output only. If set, there are currently changes in flight to the Vendor.
	VendorReconciling *bool `form:"vendor.reconciling,omitempty" json:"vendor.reconciling,omitempty"`

	// VendorEtag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	VendorEtag *string `form:"vendor.etag,omitempty" json:"vendor.etag,omitempty"`
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`
}

// VendorsCreateVendorJSONRequestBody defines body for VendorsCreateVendor for application/json ContentType.
type VendorsCreateVendorJSONRequestBody = Vendor

// Getter for additional properties for GoogleProtobufAny. Returns the specified
// element and whether it was found
func (a GoogleProtobufAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufAny
func (a *GoogleProtobufAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a *GoogleProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v1/vendors)
	VendorsListVendors(ctx echox.Context, params VendorsListVendorsParams) error

	// (POST /v1/vendors)
	VendorsCreateVendor(ctx echox.Context, params VendorsCreateVendorParams) error

	// (DELETE /v1/vendors/{vendor})
	VendorsDeleteVendor(ctx echox.Context, vendor string) error

	// (GET /v1/vendors/{vendor})
	VendorsGetVendor(ctx echox.Context, vendor string) error

	// (PATCH /v1/vendors/{vendor})
	VendorsUpdateVendor(ctx echox.Context, vendor string, params VendorsUpdateVendorParams) error
}

// ServerInterfaceWrapper converts datum echox contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// VendorsListVendors converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsListVendors(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsListVendorsParams
	// ------------- Optional query parameter "parent" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent", ctx.QueryParams(), &params.Parent)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsListVendors(ctx, params)
	return err
}

// VendorsCreateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsCreateVendor(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsCreateVendorParams
	// ------------- Optional query parameter "parent" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent", ctx.QueryParams(), &params.Parent)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent: %s", err))
	}

	// ------------- Optional query parameter "vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendorId", ctx.QueryParams(), &params.VendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendorId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsCreateVendor(ctx, params)
	return err
}

// VendorsDeleteVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsDeleteVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsDeleteVendor(ctx, vendor)
	return err
}

// VendorsGetVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsGetVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsGetVendor(ctx, vendor)
	return err
}

// VendorsUpdateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsUpdateVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsUpdateVendorParams
	// ------------- Optional query parameter "vendor.name" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.name", ctx.QueryParams(), &params.VendorName)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.name: %s", err))
	}

	// ------------- Optional query parameter "vendor.vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.vendorId", ctx.QueryParams(), &params.VendorVendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.vendorId: %s", err))
	}

	// ------------- Optional query parameter "vendor.uid" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.uid", ctx.QueryParams(), &params.VendorUid)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.uid: %s", err))
	}

	// ------------- Optional query parameter "vendor.displayName" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.displayName", ctx.QueryParams(), &params.VendorDisplayName)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.displayName: %s", err))
	}

	// ------------- Optional query parameter "vendor.createTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.createTime", ctx.QueryParams(), &params.VendorCreateTime)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.createTime: %s", err))
	}

	// ------------- Optional query parameter "vendor.updateTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.updateTime", ctx.QueryParams(), &params.VendorUpdateTime)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.updateTime: %s", err))
	}

	// ------------- Optional query parameter "vendor.deleteTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.deleteTime", ctx.QueryParams(), &params.VendorDeleteTime)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.deleteTime: %s", err))
	}

	// ------------- Optional query parameter "vendor.reconciling" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.reconciling", ctx.QueryParams(), &params.VendorReconciling)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.reconciling: %s", err))
	}

	// ------------- Optional query parameter "vendor.etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendor.etag", ctx.QueryParams(), &params.VendorEtag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor.etag: %s", err))
	}

	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsUpdateVendor(ctx, vendor, params)
	return err
}

// This is a simple interface which specifies echox.Route addition functions which
// are present on both echox.Echo and echox.Group, since we want to allow using
// either of them for path registration
type EchoxRouter interface {
	CONNECT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	DELETE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	GET(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	HEAD(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	OPTIONS(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PATCH(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	POST(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PUT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	TRACE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoxRouter, si ServerInterface, m ...echox.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoxRouter, si ServerInterface, baseURL string, m ...echox.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/vendors", wrapper.VendorsListVendors, m...)
	router.POST(baseURL+"/v1/vendors", wrapper.VendorsCreateVendor, m...)
	router.DELETE(baseURL+"/v1/vendors/:vendor", wrapper.VendorsDeleteVendor, m...)
	router.GET(baseURL+"/v1/vendors/:vendor", wrapper.VendorsGetVendor, m...)
	router.PATCH(baseURL+"/v1/vendors/:vendor", wrapper.VendorsUpdateVendor, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYX2/cuBH/KgO2Dz1A3vVdij7sU312mhq99ozYKVDYBm5WGkk8U6RCUk50xn73YoZa",
	"r+yVNxsnuTbtPVkml/P3N78Z8k7lrmmdJRuDWtypkNfUoHy+cq4ydOZddMuuPLI9L2JR6KidRXPmXUs+",
	"agpqEX1HmSoo5F63vK0W6tjZiNoGQAvolzp69D0E8hqN/oUKaCgErAjQOFvBOx1rQPhz7FuCWGOEJG5J",
	"AWJNIOuulO9tITOVqXZk0J0SQfzx0KqLvUSlsypEr22lVqv7Fbf8mfKoVpn6QYf4T7KF8+E1hdbZINoe",
	"GmHpfTzDii7cDVleeCQ4U7dJBO/pSI18/N5TqRbqd/NNauZDXuZJpdpYhN5jP23iecTYhekY/JQ2f0rB",
	"KKjUlgIgGFfpHA2Q985D4woyKRs6QOh0xKUhKJ2HQpclebIRWu8qj02jbQVkb7V3tmGbM9A2N13B669f",
	"nl/A0dkpo6GA12fH8s8MTkVwF6iAZQ+X1euz4+s/1DG2YTGfVzrW3XKWu2Ze+Tb/ZgYvMa83pq8BlK+R",
	"FmtPBK2mnAInuMCIi8GV3BWUrd1KBzMxJi0VFFGbMIN/uQ5ytFBqW4DrIjTOE+CSP2Otw4PI8PnavYPo",
	"4J3zNwnEOoK2Aq7Lo7NTOKGgKwuvOl3QxrfcuK6YVVJi4iG2OswL+e1cVIRvtkHNTkznM0hMBi/f1Tqv",
	"IdSuMwUsiSuQbNfALZpOkH85KPZtPjt2BV1vLbDu0vkGo1oobeOL7zZloW2kigSEQ9i2bToCo0NkXUOw",
	"Q4JRjt73EpxHcYeLmjwxGhBy1zTOQqCxAEFqEOwJkKJj3LCdexXONptt1VCmBlVT7hR0S4ZzcVBiLlB/",
	"CKXHMdcWXtrK6FDP4Mj2bOv00dEZ4/KBixhYgYtrjaRRfhL8Z0PkrndsQanJFBk4PxK9TOHPjSYb9yS7",
	"gXW2+A2tdRE5RuHp5jDBeo+Cu5Ei+bfQ2RB9l8fOUwE31B8k5DbYQoiOF4d2kQwTaF1ZaLDnMDJulj3Q",
	"+0jeooHonBG8yFmJrafoNd3SqDM1FJEJY3ZlGYs9oCewLsLbjnwvvCdZuc9W6ymQv2VjarLMCLrsOb0p",
	"bmEU200kc08Y6UI3EyD7sYttF8FZ089AGpVuKAnnjA2+6gBJSPGgRguMdMAHVKY8YfGjNf26MU/E39Be",
	"VvzFeUBIP+eoBdf5nDKxR1a1s2Lmmsr52JWF1rWdYRsBuaD90CE5CQgnIg48ve0oxE/wQofWYP8PnHLj",
	"r12D9oBlSOqG34LFZuj9OozRA/3A+ymNAwigwfe66RowZCum9gB/egF5jR7zSD5MlE+mKGI1RdKcuJry",
	"m9A1kkTXtF3cFKRgycMSuRm6lPI1YV9ZcLEmnwo6pMbV6KqOCe+W8wVdy+Fbx1UQTzZ0nkYFDzWGKys1",
	"1h5EdyAnkpollVwerXc5EXft2T5JMLgk8ynV/4MI+LKFT1ZA0BqMDDUoCVlFGFhbF2SjLhm4w0gHtxpB",
	"XINAhnIhp8mCtpPoY+ysq2UKc3uF1lPubK4N/7u7TE9L9l3KkgnOE+Sd5+HM9IxWy+1XWyiNQCa6EZ/s",
	"sGTpnCG0bEpoKd9vND3nX64y1eli2+jzhHEMPOZQAZ3Vbztax18zwCWp98ZJEQoGrmyaDd68OT35I6Qg",
	"SRlUHXq0kahgxzw1qBlHyW1WEbURkff50FwBA6ftlYhUWHuStsEQE3MLrzxk7iTpE5g73RdOiw9A7vTk",
	"Mclx3WgLOgZoUeb29Y/3CIGA8W2nPRVqcZnQcP3knHA+gOXRNkvRtnSypaPhvXW5HZ2dKnbOh+TM4exw",
	"9i1LdC1ZbLVaqBezw9kLnogx1sIr89tv56PrU0WR/zDzyCzBMVrLH13WRILHhpi/1eLyTmlWKE1erctZ",
	"pRCpbLgPT9DYKnvqZEXn+hd6cPaDk/Quaeny+AxTSm0i+eecdL4g/32/8+g1YyK1dYn/d4eH6YpiI4eO",
	"G0LbGp1LMuY/B2c37wsfopKpy7Xg51Ht/S21kxI7Ez+b8uHaPKHvJGka5ne/sSxTEStG0xpw6nqVqdaF",
	"pyF5LDPcMFh/YUzek8ZzzqLRzFDCDhPn75tEAoSMHt+7ov9s6Vi/eDwkIaap1RdE4FjrVwS6VTamxfld",
	"+lilbsEN70k8pqH8KTxut5rboadJLxPgMDE/xpx6nLNnMMpXVfO7utAriv+N8f1/rhcZJ/L6yZS9kXnt",
	"P5q17Dl3i6e7wEz+e77Cj50sd1iyb1v6Gu4QO9zkm9BHefirPV3sMHr8tvJRxj/nEWuHHaP3ssmBenx5",
	"+njb9r2r7cru5m74mQ38ld7edoFg80z4mX37xAeLHTaPH012jqvZ/8gL3Y5YyEvkM2b+ZObfMdxM5118",
	"PGjS/m9Txoen8s3q3TrG693V9erfAQAA//9l7m2ihB8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
