// Package proto provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package proto

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/datum-cloud/datum-os/pkg/echox"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod.
const (
	PAYMENTMETHODACH                       DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_ACH"
	PAYMENTMETHODCREDITCARD                DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_CREDIT_CARD"
	PAYMENTMETHODDOMESTICWIRETRANSFER      DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_DOMESTIC_WIRE_TRANSFER"
	PAYMENTMETHODINTERNATIONALWIRETRANSFER DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_INTERNATIONAL_WIRE_TRANSFER"
	PAYMENTMETHODUNSPECIFIED               DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_UNSPECIFIED"
)

// Defines values for DatumOsVendormanagerV1alphaVendorSpecState.
const (
	ONBOARDINGSTATEACTIVE      DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_ACTIVE"
	ONBOARDINGSTATEINACTIVE    DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_INACTIVE"
	ONBOARDINGSTATEPENDING     DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_PENDING"
	ONBOARDINGSTATEUNSPECIFIED DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_UNSPECIFIED"
)

// Defines values for DatumOsVendormanagerV1alphaVendorSpecType.
const (
	VENDORTYPECORPORATION DatumOsVendormanagerV1alphaVendorSpecType = "VENDOR_TYPE_CORPORATION"
	VENDORTYPEPERSON      DatumOsVendormanagerV1alphaVendorSpecType = "VENDOR_TYPE_PERSON"
	VENDORTYPEUNSPECIFIED DatumOsVendormanagerV1alphaVendorSpecType = "VENDOR_TYPE_UNSPECIFIED"
)

// Defines values for DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType.
const (
	TAXIDTYPEATIN        DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_ATIN"
	TAXIDTYPEEIN         DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_EIN"
	TAXIDTYPEITIN        DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_ITIN"
	TAXIDTYPESSN         DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_SSN"
	TAXIDTYPEUNSPECIFIED DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_UNSPECIFIED"
)

// DatumOsInvoicesmanagerV1alphaInvoice Invoice is a resource representing an Invoice from an organization to a
//
//	customer account or from a vendor to an organization.
type DatumOsInvoicesmanagerV1alphaInvoice struct {
	// Annotations Annotations is an unstructured key-value map stored with a Invoice that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Invoice is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Invoice that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// InvoiceId The resource ID of this Invoice within its parent resource.
	InvoiceId *string `json:"invoiceId,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Invoice that
	//  may be set by external tools to enable platform features which identify
	//  Invoices via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Invoice.
	Name *string `json:"name,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Invoice.
	Reconciling *bool `json:"reconciling,omitempty"`

	// Spec Spec is the specification of the Invoice.
	Spec DatumOsInvoicesmanagerV1alphaInvoiceSpec `json:"spec"`

	// Status Status is the current status of the Invoice.
	Status *DatumOsInvoicesmanagerV1alphaInvoiceStatus `json:"status,omitempty"`

	// Uid Server assigned unique identifier for the Invoice. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Invoice is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`
}

// DatumOsInvoicesmanagerV1alphaInvoiceSpec Spec is the specification of the Invoice. TODO!
type DatumOsInvoicesmanagerV1alphaInvoiceSpec = map[string]interface{}

// DatumOsInvoicesmanagerV1alphaInvoiceStatus Status is the current status of the Invoice. TODO!
type DatumOsInvoicesmanagerV1alphaInvoiceStatus = map[string]interface{}

// DatumOsInvoicesmanagerV1alphaListInvoicesResponse ListInvoicesResponse is the response for listing Invoices.
type DatumOsInvoicesmanagerV1alphaListInvoicesResponse struct {
	// Invoices The list of Invoices.
	Invoices *[]DatumOsInvoicesmanagerV1alphaInvoice `json:"invoices,omitempty"`

	// NextPageToken A token to retrieve the next page of results.
	//  Pass this value in the ListInvoicesRequest.page_token field in a subsequent call to `ListInvoices` to retrieve the next page of results.
	//  If the page token is not set, there are no more results.
	NextPageToken *string `json:"nextPageToken,omitempty"`
}

// DatumOsOrganizationmanagerV1alphaListOrganizationsResponse ListOrganizationsResponse is the response for listing Organizations.
type DatumOsOrganizationmanagerV1alphaListOrganizationsResponse struct {
	// NextPageToken A token to retrieve the next page of results.
	//  Pass this value in the ListOrganizationsRequest.page_token field in a subsequent call to `ListOrganizations` to retrieve the next page of results.
	//  If the page token is not set, there are no more results.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// Organizations The list of Organizations.
	Organizations *[]DatumOsOrganizationmanagerV1alphaOrganization `json:"organizations,omitempty"`
}

// DatumOsOrganizationmanagerV1alphaOrganization Organization is a resource representing an Organization.
type DatumOsOrganizationmanagerV1alphaOrganization struct {
	// Annotations Annotations is an unstructured key-value map stored with a Organization that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Organization is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Organization that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Organization that
	//  may be set by external tools to enable platform features which identify
	//  Organizations via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Organization.
	Name *string `json:"name,omitempty"`

	// OrganizationId The resource ID of this Organization within its parent resource.
	OrganizationId *string `json:"organizationId,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Organization.
	Reconciling *bool `json:"reconciling,omitempty"`

	// Spec The specifications of the Organization.
	Spec DatumOsOrganizationmanagerV1alphaSpec `json:"spec"`

	// Status The status of the Organization.
	Status *DatumOsOrganizationmanagerV1alphaStatus `json:"status,omitempty"`

	// Uid Server assigned unique identifier for the Organization. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Organization is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`
}

// DatumOsOrganizationmanagerV1alphaSpec OrganizationSpec is the specification of an Organization. TODO!
type DatumOsOrganizationmanagerV1alphaSpec = map[string]interface{}

// DatumOsOrganizationmanagerV1alphaStatus OrganizationStatus is the status of an Organization. TODO!
type DatumOsOrganizationmanagerV1alphaStatus = map[string]interface{}

// DatumOsVendormanagerV1alphaListVendorsResponse ListVendorsResponse is the response for listing Vendors.
type DatumOsVendormanagerV1alphaListVendorsResponse struct {
	// NextPageToken A token to retrieve the next page of results.
	//  Pass this value in the ListVendorsRequest.page_token field in a subsequent call to `ListVendors` to retrieve the next page of results.
	//  If the page token is not set, there are no more results.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// Vendors The list of Vendors.
	Vendors *[]DatumOsVendormanagerV1alphaVendor `json:"vendors,omitempty"`
}

// DatumOsVendormanagerV1alphaVendor Vendor is a resource representing a Vendor.
type DatumOsVendormanagerV1alphaVendor struct {
	// Annotations Annotations is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Vendor is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Vendor that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to enable platform features which identify
	//  Vendors via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Vendor.
	//  Format: vendors/{vendor}
	//  Format: organizations/{organization}/vendors/{vendor}
	Name *string `json:"name,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Vendor.
	Reconciling *bool `json:"reconciling,omitempty"`

	// Spec The specification of the Vendor.
	Spec DatumOsVendormanagerV1alphaVendorSpec `json:"spec"`

	// Uid Server assigned unique identifier for the Vendor. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Vendor is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// VendorId The resource ID of this Vendor within its parent resource.
	VendorId *string `json:"vendorId,omitempty"`
}

// DatumOsVendormanagerV1alphaVendorPaymentPreference PaymentPreference is the payment preference of a Vendor.
type DatumOsVendormanagerV1alphaVendorPaymentPreference struct {
	// Method The payment method of the Vendor.
	Method DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod `json:"method"`

	// Preferred Is this the preferred payment method?
	Preferred bool `json:"preferred"`
}

// DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod The payment method of the Vendor.
type DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod string

// DatumOsVendormanagerV1alphaVendorProfile Profile is the profile of a Vendor.
type DatumOsVendormanagerV1alphaVendorProfile struct {
	// Addresses The physical address of the person or corporation.
	Addresses *[]GoogleTypePostalAddress `json:"addresses,omitempty"`

	// Corporation The name of the corporation.
	Corporation *string `json:"corporation,omitempty"`

	// CorporationDba The DBA (Doing Business As) name of the corporation.
	CorporationDba *string `json:"corporationDba,omitempty"`

	// CorporationType The type of corporation (e.g. LLC, S-Corp, C-Corp, Other).
	CorporationType *string `json:"corporationType,omitempty"`

	// Description The description of the corporation or contractor and the services it provides.
	Description *string `json:"description,omitempty"`

	// PaymentPreference The payment preference of the Vendor.
	PaymentPreference *[]DatumOsVendormanagerV1alphaVendorPaymentPreference `json:"paymentPreference,omitempty"`

	// Person The name of the person.
	Person *string `json:"person,omitempty"`

	// PhoneNumbers The phone number of the person or corporation.
	PhoneNumbers *[]GoogleTypePhoneNumber `json:"phoneNumbers,omitempty"`

	// TaxInfo The tax information of the person or corporation.
	TaxInfo *DatumOsVendormanagerV1alphaVendorTaxInfo `json:"taxInfo,omitempty"`

	// WebsiteUri The URL of the website of the corporation or contractor.
	WebsiteUri *string `json:"websiteUri,omitempty"`
}

// DatumOsVendormanagerV1alphaVendorSpec Spec is the specification of a Vendor.
type DatumOsVendormanagerV1alphaVendorSpec struct {
	// Profile The profile of the Vendor.
	Profile DatumOsVendormanagerV1alphaVendorProfile `json:"profile"`

	// State The onboarding state of the Vendor. Defaults to ONBOARDING_STATE_PENDING on creation.
	//  (-- api-linter: core::0216::state-field-output-only=disabled
	//      aip.dev/not-precedent: We are modeling our Vendor APIs from Square's Vendor APIs.
	//      The 'state' of a Vendor is not output only. It is settable by the user. --)
	State *DatumOsVendormanagerV1alphaVendorSpecState `json:"state,omitempty"`

	// Type The type of Vendor as defined by the VendorType enum.
	Type DatumOsVendormanagerV1alphaVendorSpecType `json:"type"`
}

// DatumOsVendormanagerV1alphaVendorSpecState The onboarding state of the Vendor. Defaults to ONBOARDING_STATE_PENDING on creation.
//
//	(-- api-linter: core::0216::state-field-output-only=disabled
//	    aip.dev/not-precedent: We are modeling our Vendor APIs from Square's Vendor APIs.
//	    The 'state' of a Vendor is not output only. It is settable by the user. --)
type DatumOsVendormanagerV1alphaVendorSpecState string

// DatumOsVendormanagerV1alphaVendorSpecType The type of Vendor as defined by the VendorType enum.
type DatumOsVendormanagerV1alphaVendorSpecType string

// DatumOsVendormanagerV1alphaVendorTaxInfo TaxInfo is the tax information of a Vendor.
type DatumOsVendormanagerV1alphaVendorTaxInfo struct {
	// TaxId The tax id of the person or corporation.
	TaxId string `json:"taxId"`

	// TaxIdType The tax id type of the person or corporation.
	TaxIdType DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType `json:"taxIdType"`
}

// DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType The tax id type of the person or corporation.
type DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType string

// GoogleLongrunningOperation This resource represents a long-running operation that is the result of a
//
//	network API call.
type GoogleLongrunningOperation struct {
	// Done If the value is `false`, it means the operation is still in progress.
	//  If `true`, the operation is completed, and either `error` or `response` is
	//  available.
	Done *bool `json:"done,omitempty"`

	// Error The error result of the operation in case of failure or cancellation.
	Error *GoogleRpcStatus `json:"error,omitempty"`

	// Metadata Service-specific metadata associated with the operation.  It typically
	//  contains progress information and common metadata such as create time.
	//  Some services might not provide such metadata.  Any method that returns a
	//  long-running operation should document the metadata type, if any.
	Metadata *GoogleProtobufAny `json:"metadata,omitempty"`

	// Name The server-assigned name, which is only unique within the same service that
	//  originally returns it. If you use the default HTTP mapping, the
	//  `name` should be a resource name ending with `operations/{unique_id}`.
	Name *string `json:"name,omitempty"`

	// Response The normal response of the operation in case of success.  If the original
	//  method returns no data on success, such as `Delete`, the response is
	//  `google.protobuf.Empty`.  If the original method is standard
	//  `Get`/`Create`/`Update`, the response should be the resource.  For other
	//  methods, the response should have the type `XxxResponse`, where `Xxx`
	//  is the original method name.  For example, if the original method name
	//  is `TakeSnapshot()`, the inferred response type is
	//  `TakeSnapshotResponse`.
	Response *GoogleProtobufAny `json:"response,omitempty"`
}

// GoogleProtobufAny Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// Type The type of the serialized message.
	Type                 *string                `json:"@type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GoogleRpcStatus The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type GoogleRpcStatus struct {
	// Code The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details.  There is a common set of message types for APIs to use.
	Details *[]GoogleProtobufAny `json:"details,omitempty"`

	// Message A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message *string `json:"message,omitempty"`
}

// GoogleTypePhoneNumber An object representing a phone number, suitable as an API wire format.
//
//	This representation:
//
//	 - should not be used for locale-specific formatting of a phone number, such
//	   as "+1 (650) 253-0000 ext. 123"
//
//	 - is not designed for efficient storage
//	 - may not be suitable for dialing - specialized libraries (see references)
//	   should be used to parse the number for that purpose
//
//	To do something meaningful with this number, such as format it for various
//	use-cases, convert it to an `i18n.phonenumbers.PhoneNumber` object first.
//
//	For instance, in Java this would be:
//
//	   com.google.type.PhoneNumber wireProto =
//	       com.google.type.PhoneNumber.newBuilder().build();
//	   com.google.i18n.phonenumbers.Phonenumber.PhoneNumber phoneNumber =
//	       PhoneNumberUtil.getInstance().parse(wireProto.getE164Number(), "ZZ");
//	   if (!wireProto.getExtension().isEmpty()) {
//	     phoneNumber.setExtension(wireProto.getExtension());
//	   }
//
//	 Reference(s):
//	  - https://github.com/google/libphonenumber
type GoogleTypePhoneNumber struct {
	// E164Number The phone number, represented as a leading plus sign ('+'), followed by a
	//  phone number that uses a relaxed ITU E.164 format consisting of the
	//  country calling code (1 to 3 digits) and the subscriber number, with no
	//  additional spaces or formatting, e.g.:
	//   - correct: "+15552220123"
	//   - incorrect: "+1 (555) 222-01234 x123".
	//
	//  The ITU E.164 format limits the latter to 12 digits, but in practice not
	//  all countries respect that, so we relax that restriction here.
	//  National-only numbers are not allowed.
	//
	//  References:
	//   - https://www.itu.int/rec/T-REC-E.164-201011-I
	//   - https://en.wikipedia.org/wiki/E.164.
	//   - https://en.wikipedia.org/wiki/List_of_country_calling_codes
	E164Number *string `json:"e164Number,omitempty"`

	// Extension The phone number's extension. The extension is not standardized in ITU
	//  recommendations, except for being defined as a series of numbers with a
	//  maximum length of 40 digits. Other than digits, some other dialing
	//  characters such as ',' (indicating a wait) or '#' may be stored here.
	//
	//  Note that no regions currently use extensions with short codes, so this
	//  field is normally only set in conjunction with an E.164 number. It is held
	//  separately from the E.164 number to allow for short code extensions in the
	//  future.
	Extension *string `json:"extension,omitempty"`

	// ShortCode A short code.
	//
	//  Reference(s):
	//   - https://en.wikipedia.org/wiki/Short_code
	ShortCode *GoogleTypePhoneNumberShortCode `json:"shortCode,omitempty"`
}

// GoogleTypePhoneNumberShortCode An object representing a short code, which is a phone number that is
//
//	typically much shorter than regular phone numbers and can be used to
//	address messages in MMS and SMS systems, as well as for abbreviated dialing
//	(e.g. "Text 611 to see how many minutes you have remaining on your plan.").
//
//	Short codes are restricted to a region and are not internationally
//	dialable, which means the same short code can exist in different regions,
//	with different usage and pricing, even if those regions share the same
//	country calling code (e.g. US and CA).
type GoogleTypePhoneNumberShortCode struct {
	// Number Required. The short code digits, without a leading plus ('+') or country
	//  calling code, e.g. "611".
	Number *string `json:"number,omitempty"`

	// RegionCode Required. The BCP-47 region code of the location where calls to this
	//  short code can be made, such as "US" and "BB".
	//
	//  Reference(s):
	//   - http://www.unicode.org/reports/tr35/#unicode_region_subtag
	RegionCode *string `json:"regionCode,omitempty"`
}

// GoogleTypePostalAddress Represents a postal address, e.g. for postal delivery or payments addresses.
//
//	Given a postal address, a postal service can deliver items to a premise, P.O.
//	Box or similar.
//	It is not intended to model geographical locations (roads, towns,
//	mountains).
//
//	In typical usage an address would be created via user input or from importing
//	existing data, depending on the type of process.
//
//	Advice on address input / editing:
//	 - Use an i18n-ready address widget such as
//	   https://github.com/google/libaddressinput)
//	- Users should not be presented with UI elements for input or editing of
//	  fields outside countries where that field is used.
//
//	For more guidance on how to use this schema, please see:
//	https://support.google.com/business/answer/6397478
type GoogleTypePostalAddress struct {
	// AddressLines Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may
	//  sometimes contain multiple values in a single field (e.g.
	//  "Austin, TX"), it is important that the line order is clear. The order of
	//  address lines should be "envelope order" for the country/region of the
	//  address. In places where this can vary (e.g. Japan), address_language is
	//  used to make it explicit (e.g. "ja" for large-to-small ordering and
	//  "ja-Latn" or "en" for small-to-large). This way, the most specific line of
	//  an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists
	//  of a region_code with all remaining information placed in the
	//  address_lines. It would be possible to format such an address very
	//  approximately without geocoding, but no semantic reasoning could be
	//  made about any of the address components until it was at least
	//  partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and
	//  then geocoding is the recommended way to handle completely unstructured
	//  addresses (as opposed to guessing which parts of the address should be
	//  localities or administrative areas).
	AddressLines *[]string `json:"addressLines,omitempty"`

	// AdministrativeArea Optional. Highest administrative subdivision which is used for postal
	//  addresses of a country or region.
	//  For example, this can be a state, a province, an oblast, or a prefecture.
	//  Specifically, for Spain this is the province and not the autonomous
	//  community (e.g. "Barcelona" and not "Catalonia").
	//  Many countries don't use an administrative area in postal addresses. E.g.
	//  in Switzerland this should be left unpopulated.
	AdministrativeArea *string `json:"administrativeArea,omitempty"`

	// LanguageCode Optional. BCP-47 language code of the contents of this address (if
	//  known). This is often the UI language of the input form or is expected
	//  to match one of the languages used in the address' country/region, or their
	//  transliterated equivalents.
	//  This can affect formatting in certain countries, but is not critical
	//  to the correctness of the data and will never affect any validation or
	//  other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a
	//  possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `json:"languageCode,omitempty"`

	// Locality Optional. Generally refers to the city/town portion of the address.
	//  Examples: US city, IT comune, UK post town.
	//  In regions of the world where localities are not well defined or do not fit
	//  into this structure well, leave locality empty and use address_lines.
	Locality *string `json:"locality,omitempty"`

	// Organization Optional. The name of the organization at the address.
	Organization *string `json:"organization,omitempty"`

	// PostalCode Optional. Postal code of the address. Not all countries use or require
	//  postal codes to be present, but where they are used, they may trigger
	//  additional validation with other parts of the address (e.g. state/zip
	//  validation in the U.S.A.).
	PostalCode *string `json:"postalCode,omitempty"`

	// Recipients Optional. The recipient at the address.
	//  This field may, under certain circumstances, contain multiline information.
	//  For example, it might contain "care of" information.
	Recipients *[]string `json:"recipients,omitempty"`

	// RegionCode Required. CLDR region code of the country/region of the address. This
	//  is never inferred and it is up to the user to ensure the value is
	//  correct. See http://cldr.unicode.org/ and
	//  http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
	//  for details. Example: "CH" for Switzerland.
	RegionCode *string `json:"regionCode,omitempty"`

	// Revision The schema revision of the `PostalAddress`. This must be set to 0, which is
	//  the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	Revision *int32 `json:"revision,omitempty"`

	// SortingCode Optional. Additional, country-specific, sorting code. This is not used
	//  in most regions. Where it is used, the value is either a string like
	//  "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
	//  alone, representing the "sector code" (Jamaica), "delivery area indicator"
	//  (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode *string `json:"sortingCode,omitempty"`

	// Sublocality Optional. Sublocality of the address.
	//  For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `json:"sublocality,omitempty"`
}

// InvoicesCreateInvoiceParams defines parameters for InvoicesCreateInvoice.
type InvoicesCreateInvoiceParams struct {
	// InvoiceId The ID to use for the Invoice. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	InvoiceId *string `form:"invoiceId,omitempty" json:"invoiceId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesDeleteInvoiceParams defines parameters for InvoicesDeleteInvoice.
type InvoicesDeleteInvoiceParams struct {
	// Etag The etag of the Invoice to delete. If this is not provided, the Invoice will be deleted unconditionally.
	//  If provided, the Invoice will be deleted only if the etag matches the etag of the currently stored Invoice.
	//  If the etag is provided and does not match the etag of the currently stored Invoice, the request will be rejected.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesListInvoicesParams defines parameters for InvoicesListInvoices.
type InvoicesListInvoicesParams struct {
	// PageSize The maximum number of Invoices to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Invoices will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListInvoices` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Invoices to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Invoices. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// InvoicesUpdateInvoiceParams defines parameters for InvoicesUpdateInvoice.
type InvoicesUpdateInvoiceParams struct {
	// UpdateMask The update mask for the Invoice.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Invoice. If true, the Invoice will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// OrganizationsListOrganizationsParams defines parameters for OrganizationsListOrganizations.
type OrganizationsListOrganizationsParams struct {
	// PageSize The maximum number of Organizations to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Organizations will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListOrganizations` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Organizations to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Organizations. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// OrganizationsCreateOrganizationParams defines parameters for OrganizationsCreateOrganization.
type OrganizationsCreateOrganizationParams struct {
	// OrganizationId The ID to use for the Organization. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	OrganizationId *string `form:"organizationId,omitempty" json:"organizationId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// OrganizationsDeleteOrganizationParams defines parameters for OrganizationsDeleteOrganization.
type OrganizationsDeleteOrganizationParams struct {
	// Etag The etag of the Organization to delete. If this is not the same etag as the currently stored Organization,
	//  the request will be rejected. If not provided, the Organization will be deleted unconditionally.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// OrganizationsUpdateOrganizationParams defines parameters for OrganizationsUpdateOrganization.
type OrganizationsUpdateOrganizationParams struct {
	// UpdateMask The field mask to update the Organization.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Organization. If true, the Organization will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesCreateInvoice2Params defines parameters for InvoicesCreateInvoice2.
type InvoicesCreateInvoice2Params struct {
	// InvoiceId The ID to use for the Invoice. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	InvoiceId *string `form:"invoiceId,omitempty" json:"invoiceId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesDeleteInvoice2Params defines parameters for InvoicesDeleteInvoice2.
type InvoicesDeleteInvoice2Params struct {
	// Etag The etag of the Invoice to delete. If this is not provided, the Invoice will be deleted unconditionally.
	//  If provided, the Invoice will be deleted only if the etag matches the etag of the currently stored Invoice.
	//  If the etag is provided and does not match the etag of the currently stored Invoice, the request will be rejected.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesListInvoices2Params defines parameters for InvoicesListInvoices2.
type InvoicesListInvoices2Params struct {
	// PageSize The maximum number of Invoices to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Invoices will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListInvoices` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Invoices to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Invoices. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// InvoicesUpdateInvoice2Params defines parameters for InvoicesUpdateInvoice2.
type InvoicesUpdateInvoice2Params struct {
	// UpdateMask The update mask for the Invoice.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Invoice. If true, the Invoice will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsListVendorsParams defines parameters for VendorsListVendors.
type VendorsListVendorsParams struct {
	// PageSize The maximum number of Vendors to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Vendors will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListVendors` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Vendors to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Vendors. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// ShowDeleted If true, the deleted Vendors will be included in the response.
	ShowDeleted *bool `form:"showDeleted,omitempty" json:"showDeleted,omitempty"`
}

// VendorsCreateVendorParams defines parameters for VendorsCreateVendor.
type VendorsCreateVendorParams struct {
	// VendorId The ID to use for the Vendor. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	VendorId *string `form:"vendorId,omitempty" json:"vendorId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsDeleteVendorParams defines parameters for VendorsDeleteVendor.
type VendorsDeleteVendorParams struct {
	// Etag The etag of the Vendor to delete. If this is not the same etag as the currently stored Vendor,
	//  the request will be rejected. If not provided, the Vendor will be deleted unconditionally.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`

	// AllowMissing If true, the Vendor will be deleted successfully even if it does not exist.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// Force If true, the Vendor will be deleted even if it has child resources still existing.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// VendorsUpdateVendorParams defines parameters for VendorsUpdateVendor.
type VendorsUpdateVendorParams struct {
	// UpdateMask The field mask to update the Vendor.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Vendor. If true, the Vendor will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsListVendors2Params defines parameters for VendorsListVendors2.
type VendorsListVendors2Params struct {
	// PageSize The maximum number of Vendors to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Vendors will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListVendors` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Vendors to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Vendors. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// ShowDeleted If true, the deleted Vendors will be included in the response.
	ShowDeleted *bool `form:"showDeleted,omitempty" json:"showDeleted,omitempty"`
}

// VendorsCreateVendor2Params defines parameters for VendorsCreateVendor2.
type VendorsCreateVendor2Params struct {
	// VendorId The ID to use for the Vendor. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	VendorId *string `form:"vendorId,omitempty" json:"vendorId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsDeleteVendor2Params defines parameters for VendorsDeleteVendor2.
type VendorsDeleteVendor2Params struct {
	// Etag The etag of the Vendor to delete. If this is not the same etag as the currently stored Vendor,
	//  the request will be rejected. If not provided, the Vendor will be deleted unconditionally.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`

	// AllowMissing If true, the Vendor will be deleted successfully even if it does not exist.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// Force If true, the Vendor will be deleted even if it has child resources still existing.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// VendorsUpdateVendor2Params defines parameters for VendorsUpdateVendor2.
type VendorsUpdateVendor2Params struct {
	// UpdateMask The field mask to update the Vendor.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Vendor. If true, the Vendor will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesCreateInvoice3Params defines parameters for InvoicesCreateInvoice3.
type InvoicesCreateInvoice3Params struct {
	// InvoiceId The ID to use for the Invoice. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	InvoiceId *string `form:"invoiceId,omitempty" json:"invoiceId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesDeleteInvoice3Params defines parameters for InvoicesDeleteInvoice3.
type InvoicesDeleteInvoice3Params struct {
	// Etag The etag of the Invoice to delete. If this is not provided, the Invoice will be deleted unconditionally.
	//  If provided, the Invoice will be deleted only if the etag matches the etag of the currently stored Invoice.
	//  If the etag is provided and does not match the etag of the currently stored Invoice, the request will be rejected.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesListInvoices3Params defines parameters for InvoicesListInvoices3.
type InvoicesListInvoices3Params struct {
	// PageSize The maximum number of Invoices to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Invoices will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListInvoices` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Invoices to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Invoices. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// InvoicesUpdateInvoice3Params defines parameters for InvoicesUpdateInvoice3.
type InvoicesUpdateInvoice3Params struct {
	// UpdateMask The update mask for the Invoice.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Invoice. If true, the Invoice will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesCreateInvoiceJSONRequestBody defines body for InvoicesCreateInvoice for application/json ContentType.
type InvoicesCreateInvoiceJSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// InvoicesUpdateInvoiceJSONRequestBody defines body for InvoicesUpdateInvoice for application/json ContentType.
type InvoicesUpdateInvoiceJSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// OrganizationsCreateOrganizationJSONRequestBody defines body for OrganizationsCreateOrganization for application/json ContentType.
type OrganizationsCreateOrganizationJSONRequestBody = DatumOsOrganizationmanagerV1alphaOrganization

// OrganizationsUpdateOrganizationJSONRequestBody defines body for OrganizationsUpdateOrganization for application/json ContentType.
type OrganizationsUpdateOrganizationJSONRequestBody = DatumOsOrganizationmanagerV1alphaOrganization

// InvoicesCreateInvoice2JSONRequestBody defines body for InvoicesCreateInvoice2 for application/json ContentType.
type InvoicesCreateInvoice2JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// InvoicesUpdateInvoice2JSONRequestBody defines body for InvoicesUpdateInvoice2 for application/json ContentType.
type InvoicesUpdateInvoice2JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// VendorsCreateVendorJSONRequestBody defines body for VendorsCreateVendor for application/json ContentType.
type VendorsCreateVendorJSONRequestBody = DatumOsVendormanagerV1alphaVendor

// VendorsUpdateVendorJSONRequestBody defines body for VendorsUpdateVendor for application/json ContentType.
type VendorsUpdateVendorJSONRequestBody = DatumOsVendormanagerV1alphaVendor

// VendorsCreateVendor2JSONRequestBody defines body for VendorsCreateVendor2 for application/json ContentType.
type VendorsCreateVendor2JSONRequestBody = DatumOsVendormanagerV1alphaVendor

// VendorsUpdateVendor2JSONRequestBody defines body for VendorsUpdateVendor2 for application/json ContentType.
type VendorsUpdateVendor2JSONRequestBody = DatumOsVendormanagerV1alphaVendor

// InvoicesCreateInvoice3JSONRequestBody defines body for InvoicesCreateInvoice3 for application/json ContentType.
type InvoicesCreateInvoice3JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// InvoicesUpdateInvoice3JSONRequestBody defines body for InvoicesUpdateInvoice3 for application/json ContentType.
type InvoicesUpdateInvoice3JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// Getter for additional properties for GoogleProtobufAny. Returns the specified
// element and whether it was found
func (a GoogleProtobufAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufAny
func (a *GoogleProtobufAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a *GoogleProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /v1alpha/invoices)
	InvoicesCreateInvoice(ctx echox.Context, params InvoicesCreateInvoiceParams) error

	// (DELETE /v1alpha/invoices/{invoice})
	InvoicesDeleteInvoice(ctx echox.Context, invoice string, params InvoicesDeleteInvoiceParams) error

	// (GET /v1alpha/invoices/{invoice})
	InvoicesListInvoices(ctx echox.Context, invoice string, params InvoicesListInvoicesParams) error

	// (PATCH /v1alpha/invoices/{invoice})
	InvoicesUpdateInvoice(ctx echox.Context, invoice string, params InvoicesUpdateInvoiceParams) error

	// (GET /v1alpha/organizations)
	OrganizationsListOrganizations(ctx echox.Context, params OrganizationsListOrganizationsParams) error

	// (POST /v1alpha/organizations)
	OrganizationsCreateOrganization(ctx echox.Context, params OrganizationsCreateOrganizationParams) error

	// (DELETE /v1alpha/organizations/{organization})
	OrganizationsDeleteOrganization(ctx echox.Context, organization string, params OrganizationsDeleteOrganizationParams) error

	// (GET /v1alpha/organizations/{organization})
	OrganizationsGetOrganization(ctx echox.Context, organization string) error

	// (PATCH /v1alpha/organizations/{organization})
	OrganizationsUpdateOrganization(ctx echox.Context, organization string, params OrganizationsUpdateOrganizationParams) error

	// (POST /v1alpha/organizations/{organization}/invoices)
	InvoicesCreateInvoice2(ctx echox.Context, organization string, params InvoicesCreateInvoice2Params) error

	// (DELETE /v1alpha/organizations/{organization}/invoices/{invoice})
	InvoicesDeleteInvoice2(ctx echox.Context, organization string, invoice string, params InvoicesDeleteInvoice2Params) error

	// (GET /v1alpha/organizations/{organization}/invoices/{invoice})
	InvoicesListInvoices2(ctx echox.Context, organization string, invoice string, params InvoicesListInvoices2Params) error

	// (PATCH /v1alpha/organizations/{organization}/invoices/{invoice})
	InvoicesUpdateInvoice2(ctx echox.Context, organization string, invoice string, params InvoicesUpdateInvoice2Params) error

	// (GET /v1alpha/organizations/{organization}/vendors)
	VendorsListVendors(ctx echox.Context, organization string, params VendorsListVendorsParams) error

	// (POST /v1alpha/organizations/{organization}/vendors)
	VendorsCreateVendor(ctx echox.Context, organization string, params VendorsCreateVendorParams) error

	// (DELETE /v1alpha/organizations/{organization}/vendors/{vendor})
	VendorsDeleteVendor(ctx echox.Context, organization string, vendor string, params VendorsDeleteVendorParams) error

	// (GET /v1alpha/organizations/{organization}/vendors/{vendor})
	VendorsGetVendor(ctx echox.Context, organization string, vendor string) error

	// (PATCH /v1alpha/organizations/{organization}/vendors/{vendor})
	VendorsUpdateVendor(ctx echox.Context, organization string, vendor string, params VendorsUpdateVendorParams) error

	// (GET /v1alpha/vendors)
	VendorsListVendors2(ctx echox.Context, params VendorsListVendors2Params) error

	// (POST /v1alpha/vendors)
	VendorsCreateVendor2(ctx echox.Context, params VendorsCreateVendor2Params) error

	// (DELETE /v1alpha/vendors/{vendor})
	VendorsDeleteVendor2(ctx echox.Context, vendor string, params VendorsDeleteVendor2Params) error

	// (GET /v1alpha/vendors/{vendor})
	VendorsGetVendor2(ctx echox.Context, vendor string) error

	// (PATCH /v1alpha/vendors/{vendor})
	VendorsUpdateVendor2(ctx echox.Context, vendor string, params VendorsUpdateVendor2Params) error

	// (POST /v1alpha/vendors/{vendor}/invoices)
	InvoicesCreateInvoice3(ctx echox.Context, vendor string, params InvoicesCreateInvoice3Params) error

	// (DELETE /v1alpha/vendors/{vendor}/invoices/{invoice})
	InvoicesDeleteInvoice3(ctx echox.Context, vendor string, invoice string, params InvoicesDeleteInvoice3Params) error

	// (GET /v1alpha/vendors/{vendor}/invoices/{invoice})
	InvoicesListInvoices3(ctx echox.Context, vendor string, invoice string, params InvoicesListInvoices3Params) error

	// (PATCH /v1alpha/vendors/{vendor}/invoices/{invoice})
	InvoicesUpdateInvoice3(ctx echox.Context, vendor string, invoice string, params InvoicesUpdateInvoice3Params) error
}

// ServerInterfaceWrapper converts datum echox contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// InvoicesCreateInvoice converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesCreateInvoice(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesCreateInvoiceParams
	// ------------- Optional query parameter "invoiceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "invoiceId", ctx.QueryParams(), &params.InvoiceId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoiceId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesCreateInvoice(ctx, params)
	return err
}

// InvoicesDeleteInvoice converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesDeleteInvoice(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesDeleteInvoiceParams
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesDeleteInvoice(ctx, invoice, params)
	return err
}

// InvoicesListInvoices converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesListInvoices(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesListInvoicesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesListInvoices(ctx, invoice, params)
	return err
}

// InvoicesUpdateInvoice converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesUpdateInvoice(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesUpdateInvoiceParams
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesUpdateInvoice(ctx, invoice, params)
	return err
}

// OrganizationsListOrganizations converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsListOrganizations(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsListOrganizationsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsListOrganizations(ctx, params)
	return err
}

// OrganizationsCreateOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsCreateOrganization(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsCreateOrganizationParams
	// ------------- Optional query parameter "organizationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "organizationId", ctx.QueryParams(), &params.OrganizationId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsCreateOrganization(ctx, params)
	return err
}

// OrganizationsDeleteOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsDeleteOrganization(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsDeleteOrganizationParams
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsDeleteOrganization(ctx, organization, params)
	return err
}

// OrganizationsGetOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsGetOrganization(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsGetOrganization(ctx, organization)
	return err
}

// OrganizationsUpdateOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsUpdateOrganization(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsUpdateOrganizationParams
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsUpdateOrganization(ctx, organization, params)
	return err
}

// InvoicesCreateInvoice2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesCreateInvoice2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesCreateInvoice2Params
	// ------------- Optional query parameter "invoiceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "invoiceId", ctx.QueryParams(), &params.InvoiceId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoiceId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesCreateInvoice2(ctx, organization, params)
	return err
}

// InvoicesDeleteInvoice2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesDeleteInvoice2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesDeleteInvoice2Params
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesDeleteInvoice2(ctx, organization, invoice, params)
	return err
}

// InvoicesListInvoices2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesListInvoices2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesListInvoices2Params
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesListInvoices2(ctx, organization, invoice, params)
	return err
}

// InvoicesUpdateInvoice2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesUpdateInvoice2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesUpdateInvoice2Params
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesUpdateInvoice2(ctx, organization, invoice, params)
	return err
}

// VendorsListVendors converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsListVendors(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsListVendorsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// ------------- Optional query parameter "showDeleted" -------------

	err = runtime.BindQueryParameter("form", true, false, "showDeleted", ctx.QueryParams(), &params.ShowDeleted)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showDeleted: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsListVendors(ctx, organization, params)
	return err
}

// VendorsCreateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsCreateVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsCreateVendorParams
	// ------------- Optional query parameter "vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendorId", ctx.QueryParams(), &params.VendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendorId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsCreateVendor(ctx, organization, params)
	return err
}

// VendorsDeleteVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsDeleteVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsDeleteVendorParams
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "force" -------------

	err = runtime.BindQueryParameter("form", true, false, "force", ctx.QueryParams(), &params.Force)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter force: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsDeleteVendor(ctx, organization, vendor, params)
	return err
}

// VendorsGetVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsGetVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsGetVendor(ctx, organization, vendor)
	return err
}

// VendorsUpdateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsUpdateVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsUpdateVendorParams
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsUpdateVendor(ctx, organization, vendor, params)
	return err
}

// VendorsListVendors2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsListVendors2(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsListVendors2Params
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// ------------- Optional query parameter "showDeleted" -------------

	err = runtime.BindQueryParameter("form", true, false, "showDeleted", ctx.QueryParams(), &params.ShowDeleted)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter showDeleted: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsListVendors2(ctx, params)
	return err
}

// VendorsCreateVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsCreateVendor2(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsCreateVendor2Params
	// ------------- Optional query parameter "vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendorId", ctx.QueryParams(), &params.VendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendorId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsCreateVendor2(ctx, params)
	return err
}

// VendorsDeleteVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsDeleteVendor2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsDeleteVendor2Params
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "force" -------------

	err = runtime.BindQueryParameter("form", true, false, "force", ctx.QueryParams(), &params.Force)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter force: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsDeleteVendor2(ctx, vendor, params)
	return err
}

// VendorsGetVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsGetVendor2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsGetVendor2(ctx, vendor)
	return err
}

// VendorsUpdateVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsUpdateVendor2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsUpdateVendor2Params
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsUpdateVendor2(ctx, vendor, params)
	return err
}

// InvoicesCreateInvoice3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesCreateInvoice3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesCreateInvoice3Params
	// ------------- Optional query parameter "invoiceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "invoiceId", ctx.QueryParams(), &params.InvoiceId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoiceId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesCreateInvoice3(ctx, vendor, params)
	return err
}

// InvoicesDeleteInvoice3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesDeleteInvoice3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesDeleteInvoice3Params
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesDeleteInvoice3(ctx, vendor, invoice, params)
	return err
}

// InvoicesListInvoices3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesListInvoices3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesListInvoices3Params
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesListInvoices3(ctx, vendor, invoice, params)
	return err
}

// InvoicesUpdateInvoice3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesUpdateInvoice3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesUpdateInvoice3Params
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesUpdateInvoice3(ctx, vendor, invoice, params)
	return err
}

// This is a simple interface which specifies echox.Route addition functions which
// are present on both echox.Echo and echox.Group, since we want to allow using
// either of them for path registration
type EchoxRouter interface {
	CONNECT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	DELETE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	GET(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	HEAD(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	OPTIONS(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PATCH(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	POST(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PUT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	TRACE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoxRouter, si ServerInterface, m ...echox.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoxRouter, si ServerInterface, baseURL string, m ...echox.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/v1alpha/invoices", wrapper.InvoicesCreateInvoice, m...)
	router.DELETE(baseURL+"/v1alpha/invoices/:invoice", wrapper.InvoicesDeleteInvoice, m...)
	router.GET(baseURL+"/v1alpha/invoices/:invoice", wrapper.InvoicesListInvoices, m...)
	router.PATCH(baseURL+"/v1alpha/invoices/:invoice", wrapper.InvoicesUpdateInvoice, m...)
	router.GET(baseURL+"/v1alpha/organizations", wrapper.OrganizationsListOrganizations, m...)
	router.POST(baseURL+"/v1alpha/organizations", wrapper.OrganizationsCreateOrganization, m...)
	router.DELETE(baseURL+"/v1alpha/organizations/:organization", wrapper.OrganizationsDeleteOrganization, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization", wrapper.OrganizationsGetOrganization, m...)
	router.PATCH(baseURL+"/v1alpha/organizations/:organization", wrapper.OrganizationsUpdateOrganization, m...)
	router.POST(baseURL+"/v1alpha/organizations/:organization/invoices", wrapper.InvoicesCreateInvoice2, m...)
	router.DELETE(baseURL+"/v1alpha/organizations/:organization/invoices/:invoice", wrapper.InvoicesDeleteInvoice2, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization/invoices/:invoice", wrapper.InvoicesListInvoices2, m...)
	router.PATCH(baseURL+"/v1alpha/organizations/:organization/invoices/:invoice", wrapper.InvoicesUpdateInvoice2, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization/vendors", wrapper.VendorsListVendors, m...)
	router.POST(baseURL+"/v1alpha/organizations/:organization/vendors", wrapper.VendorsCreateVendor, m...)
	router.DELETE(baseURL+"/v1alpha/organizations/:organization/vendors/:vendor", wrapper.VendorsDeleteVendor, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization/vendors/:vendor", wrapper.VendorsGetVendor, m...)
	router.PATCH(baseURL+"/v1alpha/organizations/:organization/vendors/:vendor", wrapper.VendorsUpdateVendor, m...)
	router.GET(baseURL+"/v1alpha/vendors", wrapper.VendorsListVendors2, m...)
	router.POST(baseURL+"/v1alpha/vendors", wrapper.VendorsCreateVendor2, m...)
	router.DELETE(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsDeleteVendor2, m...)
	router.GET(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsGetVendor2, m...)
	router.PATCH(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsUpdateVendor2, m...)
	router.POST(baseURL+"/v1alpha/vendors/:vendor/invoices", wrapper.InvoicesCreateInvoice3, m...)
	router.DELETE(baseURL+"/v1alpha/vendors/:vendor/invoices/:invoice", wrapper.InvoicesDeleteInvoice3, m...)
	router.GET(baseURL+"/v1alpha/vendors/:vendor/invoices/:invoice", wrapper.InvoicesListInvoices3, m...)
	router.PATCH(baseURL+"/v1alpha/vendors/:vendor/invoices/:invoice", wrapper.InvoicesUpdateInvoice3, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//rmdod77gAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
