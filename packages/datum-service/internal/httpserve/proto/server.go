// Package proto provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package proto

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/datum-cloud/datum-os/pkg/echox"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod.
const (
	PAYMENTMETHODACH                       DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_ACH"
	PAYMENTMETHODCREDITCARD                DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_CREDIT_CARD"
	PAYMENTMETHODDOMESTICWIRETRANSFER      DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_DOMESTIC_WIRE_TRANSFER"
	PAYMENTMETHODINTERNATIONALWIRETRANSFER DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_INTERNATIONAL_WIRE_TRANSFER"
	PAYMENTMETHODUNSPECIFIED               DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod = "PAYMENT_METHOD_UNSPECIFIED"
)

// Defines values for DatumOsVendormanagerV1alphaVendorSpecState.
const (
	ONBOARDINGSTATEACTIVE      DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_ACTIVE"
	ONBOARDINGSTATEINACTIVE    DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_INACTIVE"
	ONBOARDINGSTATEPENDING     DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_PENDING"
	ONBOARDINGSTATEUNSPECIFIED DatumOsVendormanagerV1alphaVendorSpecState = "ONBOARDING_STATE_UNSPECIFIED"
)

// Defines values for DatumOsVendormanagerV1alphaVendorSpecType.
const (
	VENDORTYPECORPORATION DatumOsVendormanagerV1alphaVendorSpecType = "VENDOR_TYPE_CORPORATION"
	VENDORTYPEPERSON      DatumOsVendormanagerV1alphaVendorSpecType = "VENDOR_TYPE_PERSON"
	VENDORTYPEUNSPECIFIED DatumOsVendormanagerV1alphaVendorSpecType = "VENDOR_TYPE_UNSPECIFIED"
)

// Defines values for DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType.
const (
	TAXIDTYPEATIN        DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_ATIN"
	TAXIDTYPEEIN         DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_EIN"
	TAXIDTYPEITIN        DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_ITIN"
	TAXIDTYPESSN         DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_SSN"
	TAXIDTYPEUNSPECIFIED DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType = "TAX_ID_TYPE_UNSPECIFIED"
)

// DatumOsInvoicesmanagerV1alphaInvoice Invoice is a resource representing an Invoice from an organization to a
//
//	customer account or from a vendor to an organization.
type DatumOsInvoicesmanagerV1alphaInvoice struct {
	// Annotations Annotations is an unstructured key-value map stored with a Invoice that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Invoice is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Invoice that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// InvoiceId The resource ID of this Invoice within its parent resource.
	InvoiceId *string `json:"invoiceId,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Invoice that
	//  may be set by external tools to enable platform features which identify
	//  Invoices via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Invoice.
	Name *string `json:"name,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Invoice.
	Reconciling *bool `json:"reconciling,omitempty"`

	// Spec Spec is the specification of the Invoice.
	Spec DatumOsInvoicesmanagerV1alphaInvoiceSpec `json:"spec"`

	// Status Status is the current status of the Invoice.
	Status *DatumOsInvoicesmanagerV1alphaInvoiceStatus `json:"status,omitempty"`

	// Uid Server assigned unique identifier for the Invoice. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Invoice is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`
}

// DatumOsInvoicesmanagerV1alphaInvoiceSpec Spec is the specification of the Invoice. TODO!
type DatumOsInvoicesmanagerV1alphaInvoiceSpec = map[string]interface{}

// DatumOsInvoicesmanagerV1alphaInvoiceStatus Status is the current status of the Invoice. TODO!
type DatumOsInvoicesmanagerV1alphaInvoiceStatus = map[string]interface{}

// DatumOsInvoicesmanagerV1alphaListInvoicesResponse ListInvoicesResponse is the response for listing Invoices.
type DatumOsInvoicesmanagerV1alphaListInvoicesResponse struct {
	// Invoices The list of Invoices.
	Invoices *[]DatumOsInvoicesmanagerV1alphaInvoice `json:"invoices,omitempty"`

	// NextPageToken A token to retrieve the next page of results.
	//  Pass this value in the ListInvoicesRequest.page_token field in a subsequent call to `ListInvoices` to retrieve the next page of results.
	//  If the page token is not set, there are no more results.
	NextPageToken *string `json:"nextPageToken,omitempty"`
}

// DatumOsOrganizationmanagerV1alphaListOrganizationsResponse ListOrganizationsResponse is the response for listing Organizations.
type DatumOsOrganizationmanagerV1alphaListOrganizationsResponse struct {
	// NextPageToken A token to retrieve the next page of results.
	//  Pass this value in the ListOrganizationsRequest.page_token field in a subsequent call to `ListOrganizations` to retrieve the next page of results.
	//  If the page token is not set, there are no more results.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// Organizations The list of Organizations.
	Organizations *[]DatumOsOrganizationmanagerV1alphaOrganization `json:"organizations,omitempty"`
}

// DatumOsOrganizationmanagerV1alphaOrganization Organization is a resource representing an Organization.
type DatumOsOrganizationmanagerV1alphaOrganization struct {
	// Annotations Annotations is an unstructured key-value map stored with a Organization that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Organization is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Organization that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Organization that
	//  may be set by external tools to enable platform features which identify
	//  Organizations via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Organization.
	Name *string `json:"name,omitempty"`

	// OrganizationId The resource ID of this Organization within its parent resource.
	OrganizationId *string `json:"organizationId,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Organization.
	Reconciling *bool `json:"reconciling,omitempty"`

	// Spec The specifications of the Organization.
	Spec DatumOsOrganizationmanagerV1alphaSpec `json:"spec"`

	// Status The status of the Organization.
	Status *DatumOsOrganizationmanagerV1alphaStatus `json:"status,omitempty"`

	// Uid Server assigned unique identifier for the Organization. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Organization is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`
}

// DatumOsOrganizationmanagerV1alphaSpec OrganizationSpec is the specification of an Organization. TODO!
type DatumOsOrganizationmanagerV1alphaSpec = map[string]interface{}

// DatumOsOrganizationmanagerV1alphaStatus OrganizationStatus is the status of an Organization. TODO!
type DatumOsOrganizationmanagerV1alphaStatus = map[string]interface{}

// DatumOsVendormanagerV1alphaListVendorsResponse ListVendorsResponse is the response for listing Vendors.
type DatumOsVendormanagerV1alphaListVendorsResponse struct {
	// NextPageToken A token to retrieve the next page of results.
	//  Pass this value in the ListVendorsRequest.page_token field in a subsequent call to `ListVendors` to retrieve the next page of results.
	//  If the page token is not set, there are no more results.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// Vendors The list of Vendors.
	Vendors *[]DatumOsVendormanagerV1alphaVendor `json:"vendors,omitempty"`
}

// DatumOsVendormanagerV1alphaVendor Vendor is a resource representing a Vendor.
type DatumOsVendormanagerV1alphaVendor struct {
	// Annotations Annotations is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to store and retrieve arbitrary metadata.
	//  They are not queryable and should be preserved when modifying objects.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreateTime Output only. The time when the Vendor is created.
	CreateTime *time.Time `json:"createTime,omitempty"`

	// DeleteTime Output only. For a deleted resource, the deletion time. It is only
	//  populated as a response to a Delete request.
	DeleteTime *time.Time `json:"deleteTime,omitempty"`

	// DisplayName Human-readable display name of this Vendor that you can modify.
	//  The maximum length is 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Etag This checksum is computed by the server based on the value of
	//  other fields, and might be sent on update requests to ensure the client has
	//  an up-to-date value before proceeding.
	Etag *string `json:"etag,omitempty"`

	// Labels Labels is an unstructured key-value map stored with a Vendor that
	//  may be set by external tools to enable platform features which identify
	//  Vendors via label selections.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The resource name of this Vendor.
	//  Format: vendors/{vendor}
	//  Format: organizations/{organization}/vendors/{vendor}
	Name *string `json:"name,omitempty"`

	// Reconciling Output only. If set, there are currently changes in flight to the Vendor.
	Reconciling *bool `json:"reconciling,omitempty"`

	// Spec The specification of the Vendor.
	Spec DatumOsVendormanagerV1alphaVendorSpec `json:"spec"`

	// Uid Server assigned unique identifier for the Vendor. The value
	//  is a UUID4 string and guaranteed to remain unchanged until the resource is
	//  deleted.
	Uid *string `json:"uid,omitempty"`

	// UpdateTime Output only. The last time that the Vendor is updated.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// VendorId The resource ID of this Vendor within its parent resource.
	VendorId *string `json:"vendorId,omitempty"`
}

// DatumOsVendormanagerV1alphaVendorPaymentPreference PaymentPreference is the payment preference of a Vendor.
type DatumOsVendormanagerV1alphaVendorPaymentPreference struct {
	// Method The payment method of the Vendor.
	Method DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod `json:"method"`

	// Preferred Is this the preferred payment method?
	Preferred bool `json:"preferred"`
}

// DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod The payment method of the Vendor.
type DatumOsVendormanagerV1alphaVendorPaymentPreferenceMethod string

// DatumOsVendormanagerV1alphaVendorProfile Profile is the profile of a Vendor.
type DatumOsVendormanagerV1alphaVendorProfile struct {
	// Addresses The physical address of the person or corporation.
	Addresses *[]GoogleTypePostalAddress `json:"addresses,omitempty"`

	// Corporation The name of the corporation.
	Corporation *string `json:"corporation,omitempty"`

	// CorporationDba The DBA (Doing Business As) name of the corporation.
	CorporationDba *string `json:"corporationDba,omitempty"`

	// CorporationType The type of corporation (e.g. LLC, S-Corp, C-Corp, Other).
	CorporationType *string `json:"corporationType,omitempty"`

	// Description The description of the corporation or contractor and the services it provides.
	Description *string `json:"description,omitempty"`

	// PaymentPreference The payment preference of the Vendor.
	PaymentPreference *[]DatumOsVendormanagerV1alphaVendorPaymentPreference `json:"paymentPreference,omitempty"`

	// Person The name of the person.
	Person *string `json:"person,omitempty"`

	// PhoneNumbers The phone number of the person or corporation.
	PhoneNumbers *[]GoogleTypePhoneNumber `json:"phoneNumbers,omitempty"`

	// TaxInfo The tax information of the person or corporation.
	TaxInfo *DatumOsVendormanagerV1alphaVendorTaxInfo `json:"taxInfo,omitempty"`

	// WebsiteUri The URL of the website of the corporation or contractor.
	WebsiteUri *string `json:"websiteUri,omitempty"`
}

// DatumOsVendormanagerV1alphaVendorSpec Spec is the specification of a Vendor.
type DatumOsVendormanagerV1alphaVendorSpec struct {
	// Profile The profile of the Vendor.
	Profile DatumOsVendormanagerV1alphaVendorProfile `json:"profile"`

	// State The onboarding state of the Vendor. Defaults to ONBOARDING_STATE_PENDING on creation.
	//  (-- api-linter: core::0216::state-field-output-only=disabled
	//      aip.dev/not-precedent: We are modeling our Vendor APIs from Square's Vendor APIs.
	//      The 'state' of a Vendor is not output only. It is settable by the user. --)
	State *DatumOsVendormanagerV1alphaVendorSpecState `json:"state,omitempty"`

	// Type The type of Vendor as defined by the VendorType enum.
	Type DatumOsVendormanagerV1alphaVendorSpecType `json:"type"`
}

// DatumOsVendormanagerV1alphaVendorSpecState The onboarding state of the Vendor. Defaults to ONBOARDING_STATE_PENDING on creation.
//
//	(-- api-linter: core::0216::state-field-output-only=disabled
//	    aip.dev/not-precedent: We are modeling our Vendor APIs from Square's Vendor APIs.
//	    The 'state' of a Vendor is not output only. It is settable by the user. --)
type DatumOsVendormanagerV1alphaVendorSpecState string

// DatumOsVendormanagerV1alphaVendorSpecType The type of Vendor as defined by the VendorType enum.
type DatumOsVendormanagerV1alphaVendorSpecType string

// DatumOsVendormanagerV1alphaVendorTaxInfo TaxInfo is the tax information of a Vendor.
type DatumOsVendormanagerV1alphaVendorTaxInfo struct {
	// TaxId The tax id of the person or corporation.
	TaxId string `json:"taxId"`

	// TaxIdType The tax id type of the person or corporation.
	TaxIdType DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType `json:"taxIdType"`
}

// DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType The tax id type of the person or corporation.
type DatumOsVendormanagerV1alphaVendorTaxInfoTaxIdType string

// GoogleLongrunningOperation This resource represents a long-running operation that is the result of a
//
//	network API call.
type GoogleLongrunningOperation struct {
	// Done If the value is `false`, it means the operation is still in progress.
	//  If `true`, the operation is completed, and either `error` or `response` is
	//  available.
	Done *bool `json:"done,omitempty"`

	// Error The error result of the operation in case of failure or cancellation.
	Error *GoogleRpcStatus `json:"error,omitempty"`

	// Metadata Service-specific metadata associated with the operation.  It typically
	//  contains progress information and common metadata such as create time.
	//  Some services might not provide such metadata.  Any method that returns a
	//  long-running operation should document the metadata type, if any.
	Metadata *GoogleProtobufAny `json:"metadata,omitempty"`

	// Name The server-assigned name, which is only unique within the same service that
	//  originally returns it. If you use the default HTTP mapping, the
	//  `name` should be a resource name ending with `operations/{unique_id}`.
	Name *string `json:"name,omitempty"`

	// Response The normal response of the operation in case of success.  If the original
	//  method returns no data on success, such as `Delete`, the response is
	//  `google.protobuf.Empty`.  If the original method is standard
	//  `Get`/`Create`/`Update`, the response should be the resource.  For other
	//  methods, the response should have the type `XxxResponse`, where `Xxx`
	//  is the original method name.  For example, if the original method name
	//  is `TakeSnapshot()`, the inferred response type is
	//  `TakeSnapshotResponse`.
	Response *GoogleProtobufAny `json:"response,omitempty"`
}

// GoogleProtobufAny Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// Type The type of the serialized message.
	Type                 *string                `json:"@type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GoogleRpcStatus The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type GoogleRpcStatus struct {
	// Code The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details.  There is a common set of message types for APIs to use.
	Details *[]GoogleProtobufAny `json:"details,omitempty"`

	// Message A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message *string `json:"message,omitempty"`
}

// GoogleTypePhoneNumber An object representing a phone number, suitable as an API wire format.
//
//	This representation:
//
//	 - should not be used for locale-specific formatting of a phone number, such
//	   as "+1 (650) 253-0000 ext. 123"
//
//	 - is not designed for efficient storage
//	 - may not be suitable for dialing - specialized libraries (see references)
//	   should be used to parse the number for that purpose
//
//	To do something meaningful with this number, such as format it for various
//	use-cases, convert it to an `i18n.phonenumbers.PhoneNumber` object first.
//
//	For instance, in Java this would be:
//
//	   com.google.type.PhoneNumber wireProto =
//	       com.google.type.PhoneNumber.newBuilder().build();
//	   com.google.i18n.phonenumbers.Phonenumber.PhoneNumber phoneNumber =
//	       PhoneNumberUtil.getInstance().parse(wireProto.getE164Number(), "ZZ");
//	   if (!wireProto.getExtension().isEmpty()) {
//	     phoneNumber.setExtension(wireProto.getExtension());
//	   }
//
//	 Reference(s):
//	  - https://github.com/google/libphonenumber
type GoogleTypePhoneNumber struct {
	// E164Number The phone number, represented as a leading plus sign ('+'), followed by a
	//  phone number that uses a relaxed ITU E.164 format consisting of the
	//  country calling code (1 to 3 digits) and the subscriber number, with no
	//  additional spaces or formatting, e.g.:
	//   - correct: "+15552220123"
	//   - incorrect: "+1 (555) 222-01234 x123".
	//
	//  The ITU E.164 format limits the latter to 12 digits, but in practice not
	//  all countries respect that, so we relax that restriction here.
	//  National-only numbers are not allowed.
	//
	//  References:
	//   - https://www.itu.int/rec/T-REC-E.164-201011-I
	//   - https://en.wikipedia.org/wiki/E.164.
	//   - https://en.wikipedia.org/wiki/List_of_country_calling_codes
	E164Number *string `json:"e164Number,omitempty"`

	// Extension The phone number's extension. The extension is not standardized in ITU
	//  recommendations, except for being defined as a series of numbers with a
	//  maximum length of 40 digits. Other than digits, some other dialing
	//  characters such as ',' (indicating a wait) or '#' may be stored here.
	//
	//  Note that no regions currently use extensions with short codes, so this
	//  field is normally only set in conjunction with an E.164 number. It is held
	//  separately from the E.164 number to allow for short code extensions in the
	//  future.
	Extension *string `json:"extension,omitempty"`

	// ShortCode A short code.
	//
	//  Reference(s):
	//   - https://en.wikipedia.org/wiki/Short_code
	ShortCode *GoogleTypePhoneNumberShortCode `json:"shortCode,omitempty"`
}

// GoogleTypePhoneNumberShortCode An object representing a short code, which is a phone number that is
//
//	typically much shorter than regular phone numbers and can be used to
//	address messages in MMS and SMS systems, as well as for abbreviated dialing
//	(e.g. "Text 611 to see how many minutes you have remaining on your plan.").
//
//	Short codes are restricted to a region and are not internationally
//	dialable, which means the same short code can exist in different regions,
//	with different usage and pricing, even if those regions share the same
//	country calling code (e.g. US and CA).
type GoogleTypePhoneNumberShortCode struct {
	// Number Required. The short code digits, without a leading plus ('+') or country
	//  calling code, e.g. "611".
	Number *string `json:"number,omitempty"`

	// RegionCode Required. The BCP-47 region code of the location where calls to this
	//  short code can be made, such as "US" and "BB".
	//
	//  Reference(s):
	//   - http://www.unicode.org/reports/tr35/#unicode_region_subtag
	RegionCode *string `json:"regionCode,omitempty"`
}

// GoogleTypePostalAddress Represents a postal address, e.g. for postal delivery or payments addresses.
//
//	Given a postal address, a postal service can deliver items to a premise, P.O.
//	Box or similar.
//	It is not intended to model geographical locations (roads, towns,
//	mountains).
//
//	In typical usage an address would be created via user input or from importing
//	existing data, depending on the type of process.
//
//	Advice on address input / editing:
//	 - Use an i18n-ready address widget such as
//	   https://github.com/google/libaddressinput)
//	- Users should not be presented with UI elements for input or editing of
//	  fields outside countries where that field is used.
//
//	For more guidance on how to use this schema, please see:
//	https://support.google.com/business/answer/6397478
type GoogleTypePostalAddress struct {
	// AddressLines Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may
	//  sometimes contain multiple values in a single field (e.g.
	//  "Austin, TX"), it is important that the line order is clear. The order of
	//  address lines should be "envelope order" for the country/region of the
	//  address. In places where this can vary (e.g. Japan), address_language is
	//  used to make it explicit (e.g. "ja" for large-to-small ordering and
	//  "ja-Latn" or "en" for small-to-large). This way, the most specific line of
	//  an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists
	//  of a region_code with all remaining information placed in the
	//  address_lines. It would be possible to format such an address very
	//  approximately without geocoding, but no semantic reasoning could be
	//  made about any of the address components until it was at least
	//  partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and
	//  then geocoding is the recommended way to handle completely unstructured
	//  addresses (as opposed to guessing which parts of the address should be
	//  localities or administrative areas).
	AddressLines *[]string `json:"addressLines,omitempty"`

	// AdministrativeArea Optional. Highest administrative subdivision which is used for postal
	//  addresses of a country or region.
	//  For example, this can be a state, a province, an oblast, or a prefecture.
	//  Specifically, for Spain this is the province and not the autonomous
	//  community (e.g. "Barcelona" and not "Catalonia").
	//  Many countries don't use an administrative area in postal addresses. E.g.
	//  in Switzerland this should be left unpopulated.
	AdministrativeArea *string `json:"administrativeArea,omitempty"`

	// LanguageCode Optional. BCP-47 language code of the contents of this address (if
	//  known). This is often the UI language of the input form or is expected
	//  to match one of the languages used in the address' country/region, or their
	//  transliterated equivalents.
	//  This can affect formatting in certain countries, but is not critical
	//  to the correctness of the data and will never affect any validation or
	//  other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a
	//  possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `json:"languageCode,omitempty"`

	// Locality Optional. Generally refers to the city/town portion of the address.
	//  Examples: US city, IT comune, UK post town.
	//  In regions of the world where localities are not well defined or do not fit
	//  into this structure well, leave locality empty and use address_lines.
	Locality *string `json:"locality,omitempty"`

	// Organization Optional. The name of the organization at the address.
	Organization *string `json:"organization,omitempty"`

	// PostalCode Optional. Postal code of the address. Not all countries use or require
	//  postal codes to be present, but where they are used, they may trigger
	//  additional validation with other parts of the address (e.g. state/zip
	//  validation in the U.S.A.).
	PostalCode *string `json:"postalCode,omitempty"`

	// Recipients Optional. The recipient at the address.
	//  This field may, under certain circumstances, contain multiline information.
	//  For example, it might contain "care of" information.
	Recipients *[]string `json:"recipients,omitempty"`

	// RegionCode Required. CLDR region code of the country/region of the address. This
	//  is never inferred and it is up to the user to ensure the value is
	//  correct. See http://cldr.unicode.org/ and
	//  http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
	//  for details. Example: "CH" for Switzerland.
	RegionCode *string `json:"regionCode,omitempty"`

	// Revision The schema revision of the `PostalAddress`. This must be set to 0, which is
	//  the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	Revision *int32 `json:"revision,omitempty"`

	// SortingCode Optional. Additional, country-specific, sorting code. This is not used
	//  in most regions. Where it is used, the value is either a string like
	//  "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
	//  alone, representing the "sector code" (Jamaica), "delivery area indicator"
	//  (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode *string `json:"sortingCode,omitempty"`

	// Sublocality Optional. Sublocality of the address.
	//  For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `json:"sublocality,omitempty"`
}

// InvoicesCreateInvoiceParams defines parameters for InvoicesCreateInvoice.
type InvoicesCreateInvoiceParams struct {
	// InvoiceId The ID to use for the Invoice. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	InvoiceId *string `form:"invoiceId,omitempty" json:"invoiceId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesDeleteInvoiceParams defines parameters for InvoicesDeleteInvoice.
type InvoicesDeleteInvoiceParams struct {
	// Etag The etag of the Invoice to delete. If this is not provided, the Invoice will be deleted unconditionally.
	//  If provided, the Invoice will be deleted only if the etag matches the etag of the currently stored Invoice.
	//  If the etag is provided and does not match the etag of the currently stored Invoice, the request will be rejected.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesListInvoicesParams defines parameters for InvoicesListInvoices.
type InvoicesListInvoicesParams struct {
	// PageSize The maximum number of Invoices to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Invoices will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListInvoices` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Invoices to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Invoices. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// InvoicesUpdateInvoiceParams defines parameters for InvoicesUpdateInvoice.
type InvoicesUpdateInvoiceParams struct {
	// UpdateMask The update mask for the Invoice.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Invoice. If true, the Invoice will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// OrganizationsListOrganizationsParams defines parameters for OrganizationsListOrganizations.
type OrganizationsListOrganizationsParams struct {
	// PageSize The maximum number of Organizations to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Organizations will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListOrganizations` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Organizations to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Organizations. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// OrganizationsCreateOrganizationParams defines parameters for OrganizationsCreateOrganization.
type OrganizationsCreateOrganizationParams struct {
	// OrganizationId The ID to use for the Organization. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	OrganizationId *string `form:"organizationId,omitempty" json:"organizationId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// OrganizationsDeleteOrganizationParams defines parameters for OrganizationsDeleteOrganization.
type OrganizationsDeleteOrganizationParams struct {
	// Etag The etag of the Organization to delete. If this is not the same etag as the currently stored Organization,
	//  the request will be rejected. If not provided, the Organization will be deleted unconditionally.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// OrganizationsUpdateOrganizationParams defines parameters for OrganizationsUpdateOrganization.
type OrganizationsUpdateOrganizationParams struct {
	// UpdateMask The field mask to update the Organization.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Organization. If true, the Organization will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesCreateInvoice2Params defines parameters for InvoicesCreateInvoice2.
type InvoicesCreateInvoice2Params struct {
	// InvoiceId The ID to use for the Invoice. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	InvoiceId *string `form:"invoiceId,omitempty" json:"invoiceId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesDeleteInvoice2Params defines parameters for InvoicesDeleteInvoice2.
type InvoicesDeleteInvoice2Params struct {
	// Etag The etag of the Invoice to delete. If this is not provided, the Invoice will be deleted unconditionally.
	//  If provided, the Invoice will be deleted only if the etag matches the etag of the currently stored Invoice.
	//  If the etag is provided and does not match the etag of the currently stored Invoice, the request will be rejected.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesListInvoices2Params defines parameters for InvoicesListInvoices2.
type InvoicesListInvoices2Params struct {
	// PageSize The maximum number of Invoices to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Invoices will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListInvoices` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Invoices to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Invoices. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// InvoicesUpdateInvoice2Params defines parameters for InvoicesUpdateInvoice2.
type InvoicesUpdateInvoice2Params struct {
	// UpdateMask The update mask for the Invoice.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Invoice. If true, the Invoice will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsListVendorsParams defines parameters for VendorsListVendors.
type VendorsListVendorsParams struct {
	// PageSize The maximum number of Vendors to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Vendors will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListVendors` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Vendors to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Vendors. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// VendorsCreateVendorParams defines parameters for VendorsCreateVendor.
type VendorsCreateVendorParams struct {
	// VendorId The ID to use for the Vendor. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	VendorId *string `form:"vendorId,omitempty" json:"vendorId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsDeleteVendorParams defines parameters for VendorsDeleteVendor.
type VendorsDeleteVendorParams struct {
	// Etag The etag of the Vendor to delete. If this is not the same etag as the currently stored Vendor,
	//  the request will be rejected. If not provided, the Vendor will be deleted unconditionally.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsUpdateVendorParams defines parameters for VendorsUpdateVendor.
type VendorsUpdateVendorParams struct {
	// UpdateMask The field mask to update the Vendor.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Vendor. If true, the Vendor will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsListVendors2Params defines parameters for VendorsListVendors2.
type VendorsListVendors2Params struct {
	// PageSize The maximum number of Vendors to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Vendors will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListVendors` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Vendors to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Vendors. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// VendorsCreateVendor2Params defines parameters for VendorsCreateVendor2.
type VendorsCreateVendor2Params struct {
	// VendorId The ID to use for the Vendor. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	VendorId *string `form:"vendorId,omitempty" json:"vendorId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsDeleteVendor2Params defines parameters for VendorsDeleteVendor2.
type VendorsDeleteVendor2Params struct {
	// Etag The etag of the Vendor to delete. If this is not the same etag as the currently stored Vendor,
	//  the request will be rejected. If not provided, the Vendor will be deleted unconditionally.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// VendorsUpdateVendor2Params defines parameters for VendorsUpdateVendor2.
type VendorsUpdateVendor2Params struct {
	// UpdateMask The field mask to update the Vendor.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Vendor. If true, the Vendor will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesCreateInvoice3Params defines parameters for InvoicesCreateInvoice3.
type InvoicesCreateInvoice3Params struct {
	// InvoiceId The ID to use for the Invoice. If not specified, an ID will be automatically generated.
	//  If the ID is automatically generated, the Client is responsible for reconciliation.
	InvoiceId *string `form:"invoiceId,omitempty" json:"invoiceId,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesDeleteInvoice3Params defines parameters for InvoicesDeleteInvoice3.
type InvoicesDeleteInvoice3Params struct {
	// Etag The etag of the Invoice to delete. If this is not provided, the Invoice will be deleted unconditionally.
	//  If provided, the Invoice will be deleted only if the etag matches the etag of the currently stored Invoice.
	//  If the etag is provided and does not match the etag of the currently stored Invoice, the request will be rejected.
	Etag *string `form:"etag,omitempty" json:"etag,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesListInvoices3Params defines parameters for InvoicesListInvoices3.
type InvoicesListInvoices3Params struct {
	// PageSize The maximum number of Invoices to return. The service may return fewer than this value.
	//  If unspecified, at most 50 Invoices will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken A page token, received from a previous `ListInvoices` call. Provide this to retrieve the subsequent page.
	//  When paginating, all other parameters must match the call that provided the page token.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Filter A filter expression that filters the Invoices to be listed.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// OrderBy The order by fields for the Invoices. The default order is ascending. There is no descending order.
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// InvoicesUpdateInvoice3Params defines parameters for InvoicesUpdateInvoice3.
type InvoicesUpdateInvoice3Params struct {
	// UpdateMask The update mask for the Invoice.
	UpdateMask *string `form:"updateMask,omitempty" json:"updateMask,omitempty"`

	// AllowMissing Allow missing Invoice. If true, the Invoice will be created if it does not exist. In this case,
	//  field_mask is ignored.
	AllowMissing *bool `form:"allowMissing,omitempty" json:"allowMissing,omitempty"`

	// ValidateOnly If true, the request is validated and nothing is persisted.
	ValidateOnly *bool `form:"validateOnly,omitempty" json:"validateOnly,omitempty"`
}

// InvoicesCreateInvoiceJSONRequestBody defines body for InvoicesCreateInvoice for application/json ContentType.
type InvoicesCreateInvoiceJSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// InvoicesUpdateInvoiceJSONRequestBody defines body for InvoicesUpdateInvoice for application/json ContentType.
type InvoicesUpdateInvoiceJSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// OrganizationsCreateOrganizationJSONRequestBody defines body for OrganizationsCreateOrganization for application/json ContentType.
type OrganizationsCreateOrganizationJSONRequestBody = DatumOsOrganizationmanagerV1alphaOrganization

// OrganizationsUpdateOrganizationJSONRequestBody defines body for OrganizationsUpdateOrganization for application/json ContentType.
type OrganizationsUpdateOrganizationJSONRequestBody = DatumOsOrganizationmanagerV1alphaOrganization

// InvoicesCreateInvoice2JSONRequestBody defines body for InvoicesCreateInvoice2 for application/json ContentType.
type InvoicesCreateInvoice2JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// InvoicesUpdateInvoice2JSONRequestBody defines body for InvoicesUpdateInvoice2 for application/json ContentType.
type InvoicesUpdateInvoice2JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// VendorsCreateVendorJSONRequestBody defines body for VendorsCreateVendor for application/json ContentType.
type VendorsCreateVendorJSONRequestBody = DatumOsVendormanagerV1alphaVendor

// VendorsUpdateVendorJSONRequestBody defines body for VendorsUpdateVendor for application/json ContentType.
type VendorsUpdateVendorJSONRequestBody = DatumOsVendormanagerV1alphaVendor

// VendorsCreateVendor2JSONRequestBody defines body for VendorsCreateVendor2 for application/json ContentType.
type VendorsCreateVendor2JSONRequestBody = DatumOsVendormanagerV1alphaVendor

// VendorsUpdateVendor2JSONRequestBody defines body for VendorsUpdateVendor2 for application/json ContentType.
type VendorsUpdateVendor2JSONRequestBody = DatumOsVendormanagerV1alphaVendor

// InvoicesCreateInvoice3JSONRequestBody defines body for InvoicesCreateInvoice3 for application/json ContentType.
type InvoicesCreateInvoice3JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// InvoicesUpdateInvoice3JSONRequestBody defines body for InvoicesUpdateInvoice3 for application/json ContentType.
type InvoicesUpdateInvoice3JSONRequestBody = DatumOsInvoicesmanagerV1alphaInvoice

// Getter for additional properties for GoogleProtobufAny. Returns the specified
// element and whether it was found
func (a GoogleProtobufAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufAny
func (a *GoogleProtobufAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a *GoogleProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /v1alpha/invoices)
	InvoicesCreateInvoice(ctx echox.Context, params InvoicesCreateInvoiceParams) error

	// (DELETE /v1alpha/invoices/{invoice})
	InvoicesDeleteInvoice(ctx echox.Context, invoice string, params InvoicesDeleteInvoiceParams) error

	// (GET /v1alpha/invoices/{invoice})
	InvoicesListInvoices(ctx echox.Context, invoice string, params InvoicesListInvoicesParams) error

	// (PATCH /v1alpha/invoices/{invoice})
	InvoicesUpdateInvoice(ctx echox.Context, invoice string, params InvoicesUpdateInvoiceParams) error

	// (GET /v1alpha/organizations)
	OrganizationsListOrganizations(ctx echox.Context, params OrganizationsListOrganizationsParams) error

	// (POST /v1alpha/organizations)
	OrganizationsCreateOrganization(ctx echox.Context, params OrganizationsCreateOrganizationParams) error

	// (DELETE /v1alpha/organizations/{organization})
	OrganizationsDeleteOrganization(ctx echox.Context, organization string, params OrganizationsDeleteOrganizationParams) error

	// (GET /v1alpha/organizations/{organization})
	OrganizationsGetOrganization(ctx echox.Context, organization string) error

	// (PATCH /v1alpha/organizations/{organization})
	OrganizationsUpdateOrganization(ctx echox.Context, organization string, params OrganizationsUpdateOrganizationParams) error

	// (POST /v1alpha/organizations/{organization}/invoices)
	InvoicesCreateInvoice2(ctx echox.Context, organization string, params InvoicesCreateInvoice2Params) error

	// (DELETE /v1alpha/organizations/{organization}/invoices/{invoice})
	InvoicesDeleteInvoice2(ctx echox.Context, organization string, invoice string, params InvoicesDeleteInvoice2Params) error

	// (GET /v1alpha/organizations/{organization}/invoices/{invoice})
	InvoicesListInvoices2(ctx echox.Context, organization string, invoice string, params InvoicesListInvoices2Params) error

	// (PATCH /v1alpha/organizations/{organization}/invoices/{invoice})
	InvoicesUpdateInvoice2(ctx echox.Context, organization string, invoice string, params InvoicesUpdateInvoice2Params) error

	// (GET /v1alpha/organizations/{organization}/vendors)
	VendorsListVendors(ctx echox.Context, organization string, params VendorsListVendorsParams) error

	// (POST /v1alpha/organizations/{organization}/vendors)
	VendorsCreateVendor(ctx echox.Context, organization string, params VendorsCreateVendorParams) error

	// (DELETE /v1alpha/organizations/{organization}/vendors/{vendor})
	VendorsDeleteVendor(ctx echox.Context, organization string, vendor string, params VendorsDeleteVendorParams) error

	// (GET /v1alpha/organizations/{organization}/vendors/{vendor})
	VendorsGetVendor(ctx echox.Context, organization string, vendor string) error

	// (PATCH /v1alpha/organizations/{organization}/vendors/{vendor})
	VendorsUpdateVendor(ctx echox.Context, organization string, vendor string, params VendorsUpdateVendorParams) error

	// (GET /v1alpha/vendors)
	VendorsListVendors2(ctx echox.Context, params VendorsListVendors2Params) error

	// (POST /v1alpha/vendors)
	VendorsCreateVendor2(ctx echox.Context, params VendorsCreateVendor2Params) error

	// (DELETE /v1alpha/vendors/{vendor})
	VendorsDeleteVendor2(ctx echox.Context, vendor string, params VendorsDeleteVendor2Params) error

	// (GET /v1alpha/vendors/{vendor})
	VendorsGetVendor2(ctx echox.Context, vendor string) error

	// (PATCH /v1alpha/vendors/{vendor})
	VendorsUpdateVendor2(ctx echox.Context, vendor string, params VendorsUpdateVendor2Params) error

	// (POST /v1alpha/vendors/{vendor}/invoices)
	InvoicesCreateInvoice3(ctx echox.Context, vendor string, params InvoicesCreateInvoice3Params) error

	// (DELETE /v1alpha/vendors/{vendor}/invoices/{invoice})
	InvoicesDeleteInvoice3(ctx echox.Context, vendor string, invoice string, params InvoicesDeleteInvoice3Params) error

	// (GET /v1alpha/vendors/{vendor}/invoices/{invoice})
	InvoicesListInvoices3(ctx echox.Context, vendor string, invoice string, params InvoicesListInvoices3Params) error

	// (PATCH /v1alpha/vendors/{vendor}/invoices/{invoice})
	InvoicesUpdateInvoice3(ctx echox.Context, vendor string, invoice string, params InvoicesUpdateInvoice3Params) error
}

// ServerInterfaceWrapper converts datum echox contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// InvoicesCreateInvoice converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesCreateInvoice(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesCreateInvoiceParams
	// ------------- Optional query parameter "invoiceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "invoiceId", ctx.QueryParams(), &params.InvoiceId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoiceId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesCreateInvoice(ctx, params)
	return err
}

// InvoicesDeleteInvoice converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesDeleteInvoice(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesDeleteInvoiceParams
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesDeleteInvoice(ctx, invoice, params)
	return err
}

// InvoicesListInvoices converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesListInvoices(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesListInvoicesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesListInvoices(ctx, invoice, params)
	return err
}

// InvoicesUpdateInvoice converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesUpdateInvoice(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesUpdateInvoiceParams
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesUpdateInvoice(ctx, invoice, params)
	return err
}

// OrganizationsListOrganizations converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsListOrganizations(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsListOrganizationsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsListOrganizations(ctx, params)
	return err
}

// OrganizationsCreateOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsCreateOrganization(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsCreateOrganizationParams
	// ------------- Optional query parameter "organizationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "organizationId", ctx.QueryParams(), &params.OrganizationId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsCreateOrganization(ctx, params)
	return err
}

// OrganizationsDeleteOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsDeleteOrganization(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsDeleteOrganizationParams
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsDeleteOrganization(ctx, organization, params)
	return err
}

// OrganizationsGetOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsGetOrganization(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsGetOrganization(ctx, organization)
	return err
}

// OrganizationsUpdateOrganization converts echox context to params.
func (w *ServerInterfaceWrapper) OrganizationsUpdateOrganization(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params OrganizationsUpdateOrganizationParams
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrganizationsUpdateOrganization(ctx, organization, params)
	return err
}

// InvoicesCreateInvoice2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesCreateInvoice2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesCreateInvoice2Params
	// ------------- Optional query parameter "invoiceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "invoiceId", ctx.QueryParams(), &params.InvoiceId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoiceId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesCreateInvoice2(ctx, organization, params)
	return err
}

// InvoicesDeleteInvoice2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesDeleteInvoice2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesDeleteInvoice2Params
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesDeleteInvoice2(ctx, organization, invoice, params)
	return err
}

// InvoicesListInvoices2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesListInvoices2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesListInvoices2Params
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesListInvoices2(ctx, organization, invoice, params)
	return err
}

// InvoicesUpdateInvoice2 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesUpdateInvoice2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesUpdateInvoice2Params
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesUpdateInvoice2(ctx, organization, invoice, params)
	return err
}

// VendorsListVendors converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsListVendors(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsListVendorsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsListVendors(ctx, organization, params)
	return err
}

// VendorsCreateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsCreateVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsCreateVendorParams
	// ------------- Optional query parameter "vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendorId", ctx.QueryParams(), &params.VendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendorId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsCreateVendor(ctx, organization, params)
	return err
}

// VendorsDeleteVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsDeleteVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsDeleteVendorParams
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsDeleteVendor(ctx, organization, vendor, params)
	return err
}

// VendorsGetVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsGetVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsGetVendor(ctx, organization, vendor)
	return err
}

// VendorsUpdateVendor converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsUpdateVendor(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "organization" -------------
	var organization string

	err = runtime.BindStyledParameterWithOptions("simple", "organization", ctx.Param("organization"), &organization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization: %s", err))
	}

	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsUpdateVendorParams
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsUpdateVendor(ctx, organization, vendor, params)
	return err
}

// VendorsListVendors2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsListVendors2(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsListVendors2Params
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsListVendors2(ctx, params)
	return err
}

// VendorsCreateVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsCreateVendor2(ctx echox.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsCreateVendor2Params
	// ------------- Optional query parameter "vendorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "vendorId", ctx.QueryParams(), &params.VendorId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendorId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsCreateVendor2(ctx, params)
	return err
}

// VendorsDeleteVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsDeleteVendor2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsDeleteVendor2Params
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsDeleteVendor2(ctx, vendor, params)
	return err
}

// VendorsGetVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsGetVendor2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsGetVendor2(ctx, vendor)
	return err
}

// VendorsUpdateVendor2 converts echox context to params.
func (w *ServerInterfaceWrapper) VendorsUpdateVendor2(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VendorsUpdateVendor2Params
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VendorsUpdateVendor2(ctx, vendor, params)
	return err
}

// InvoicesCreateInvoice3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesCreateInvoice3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesCreateInvoice3Params
	// ------------- Optional query parameter "invoiceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "invoiceId", ctx.QueryParams(), &params.InvoiceId)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoiceId: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesCreateInvoice3(ctx, vendor, params)
	return err
}

// InvoicesDeleteInvoice3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesDeleteInvoice3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesDeleteInvoice3Params
	// ------------- Optional query parameter "etag" -------------

	err = runtime.BindQueryParameter("form", true, false, "etag", ctx.QueryParams(), &params.Etag)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter etag: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesDeleteInvoice3(ctx, vendor, invoice, params)
	return err
}

// InvoicesListInvoices3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesListInvoices3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesListInvoices3Params
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "pageToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageToken", ctx.QueryParams(), &params.PageToken)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageToken: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderBy: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesListInvoices3(ctx, vendor, invoice, params)
	return err
}

// InvoicesUpdateInvoice3 converts echox context to params.
func (w *ServerInterfaceWrapper) InvoicesUpdateInvoice3(ctx echox.Context) error {
	var err error
	// ------------- Path parameter "vendor" -------------
	var vendor string

	err = runtime.BindStyledParameterWithOptions("simple", "vendor", ctx.Param("vendor"), &vendor, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vendor: %s", err))
	}

	// ------------- Path parameter "invoice" -------------
	var invoice string

	err = runtime.BindStyledParameterWithOptions("simple", "invoice", ctx.Param("invoice"), &invoice, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invoice: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params InvoicesUpdateInvoice3Params
	// ------------- Optional query parameter "updateMask" -------------

	err = runtime.BindQueryParameter("form", true, false, "updateMask", ctx.QueryParams(), &params.UpdateMask)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updateMask: %s", err))
	}

	// ------------- Optional query parameter "allowMissing" -------------

	err = runtime.BindQueryParameter("form", true, false, "allowMissing", ctx.QueryParams(), &params.AllowMissing)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allowMissing: %s", err))
	}

	// ------------- Optional query parameter "validateOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "validateOnly", ctx.QueryParams(), &params.ValidateOnly)
	if err != nil {
		return echox.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter validateOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InvoicesUpdateInvoice3(ctx, vendor, invoice, params)
	return err
}

// This is a simple interface which specifies echox.Route addition functions which
// are present on both echox.Echo and echox.Group, since we want to allow using
// either of them for path registration
type EchoxRouter interface {
	CONNECT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	DELETE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	GET(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	HEAD(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	OPTIONS(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PATCH(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	POST(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	PUT(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
	TRACE(path string, h echox.HandlerFunc, m ...echox.MiddlewareFunc) echox.RouteInfo
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoxRouter, si ServerInterface, m ...echox.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoxRouter, si ServerInterface, baseURL string, m ...echox.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/v1alpha/invoices", wrapper.InvoicesCreateInvoice, m...)
	router.DELETE(baseURL+"/v1alpha/invoices/:invoice", wrapper.InvoicesDeleteInvoice, m...)
	router.GET(baseURL+"/v1alpha/invoices/:invoice", wrapper.InvoicesListInvoices, m...)
	router.PATCH(baseURL+"/v1alpha/invoices/:invoice", wrapper.InvoicesUpdateInvoice, m...)
	router.GET(baseURL+"/v1alpha/organizations", wrapper.OrganizationsListOrganizations, m...)
	router.POST(baseURL+"/v1alpha/organizations", wrapper.OrganizationsCreateOrganization, m...)
	router.DELETE(baseURL+"/v1alpha/organizations/:organization", wrapper.OrganizationsDeleteOrganization, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization", wrapper.OrganizationsGetOrganization, m...)
	router.PATCH(baseURL+"/v1alpha/organizations/:organization", wrapper.OrganizationsUpdateOrganization, m...)
	router.POST(baseURL+"/v1alpha/organizations/:organization/invoices", wrapper.InvoicesCreateInvoice2, m...)
	router.DELETE(baseURL+"/v1alpha/organizations/:organization/invoices/:invoice", wrapper.InvoicesDeleteInvoice2, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization/invoices/:invoice", wrapper.InvoicesListInvoices2, m...)
	router.PATCH(baseURL+"/v1alpha/organizations/:organization/invoices/:invoice", wrapper.InvoicesUpdateInvoice2, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization/vendors", wrapper.VendorsListVendors, m...)
	router.POST(baseURL+"/v1alpha/organizations/:organization/vendors", wrapper.VendorsCreateVendor, m...)
	router.DELETE(baseURL+"/v1alpha/organizations/:organization/vendors/:vendor", wrapper.VendorsDeleteVendor, m...)
	router.GET(baseURL+"/v1alpha/organizations/:organization/vendors/:vendor", wrapper.VendorsGetVendor, m...)
	router.PATCH(baseURL+"/v1alpha/organizations/:organization/vendors/:vendor", wrapper.VendorsUpdateVendor, m...)
	router.GET(baseURL+"/v1alpha/vendors", wrapper.VendorsListVendors2, m...)
	router.POST(baseURL+"/v1alpha/vendors", wrapper.VendorsCreateVendor2, m...)
	router.DELETE(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsDeleteVendor2, m...)
	router.GET(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsGetVendor2, m...)
	router.PATCH(baseURL+"/v1alpha/vendors/:vendor", wrapper.VendorsUpdateVendor2, m...)
	router.POST(baseURL+"/v1alpha/vendors/:vendor/invoices", wrapper.InvoicesCreateInvoice3, m...)
	router.DELETE(baseURL+"/v1alpha/vendors/:vendor/invoices/:invoice", wrapper.InvoicesDeleteInvoice3, m...)
	router.GET(baseURL+"/v1alpha/vendors/:vendor/invoices/:invoice", wrapper.InvoicesListInvoices3, m...)
	router.PATCH(baseURL+"/v1alpha/vendors/:vendor/invoices/:invoice", wrapper.InvoicesUpdateInvoice3, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
