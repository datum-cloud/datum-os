// Code generated by ent, DO NOT EDIT.

package generated

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/datum-cloud/datum-os/internal/ent/generated/postaladdresshistory"
	"github.com/datum-cloud/datum-os/pkg/enthistory"
)

// PostalAddressHistory is the model entity for the PostalAddressHistory schema.
type PostalAddressHistory struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// HistoryTime holds the value of the "history_time" field.
	HistoryTime time.Time `json:"history_time,omitempty"`
	// Ref holds the value of the "ref" field.
	Ref string `json:"ref,omitempty"`
	// Operation holds the value of the "operation" field.
	Operation enthistory.OpType `json:"operation,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// UpdatedBy holds the value of the "updated_by" field.
	UpdatedBy string `json:"updated_by,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// DeletedBy holds the value of the "deleted_by" field.
	DeletedBy *string `json:"deleted_by,omitempty"`
	// MappingID holds the value of the "mapping_id" field.
	MappingID string `json:"mapping_id,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID string `json:"owner_id,omitempty"`
	// CLDR region code of the country/region of the address. See https://cldr.unicode.org/ for more details.
	RegionCode string `json:"region_code,omitempty"`
	// BCP-47 language code of the contents of this address (if known).
	LanguageCode *string `json:"language_code,omitempty"`
	// Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `json:"postal_code,omitempty"`
	// Additional, country-specific, sorting code. This is not used in most regions.
	SortingCode *string `json:"sorting_code,omitempty"`
	// Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture.
	AdministrativeArea *string `json:"administrative_area,omitempty"`
	// Locality of the address. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town.
	Locality *string `json:"locality,omitempty"`
	// Sublocality of the address. This is the neighborhood, district, or town.
	Sublocality *string `json:"sublocality,omitempty"`
	// Unstructured address lines describing the lower levels of an address.
	AddressLines []string `json:"address_lines,omitempty"`
	// Recipients of the address. This field may, under certain circumstances, contain multiline information. For example, it might contain 'care of' information.
	Recipients []string `json:"recipients,omitempty"`
	// Organization of the address.
	Organization *string `json:"organization,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*PostalAddressHistory) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case postaladdresshistory.FieldTags, postaladdresshistory.FieldAddressLines, postaladdresshistory.FieldRecipients:
			values[i] = new([]byte)
		case postaladdresshistory.FieldOperation:
			values[i] = new(enthistory.OpType)
		case postaladdresshistory.FieldID, postaladdresshistory.FieldRef, postaladdresshistory.FieldCreatedBy, postaladdresshistory.FieldUpdatedBy, postaladdresshistory.FieldDeletedBy, postaladdresshistory.FieldMappingID, postaladdresshistory.FieldOwnerID, postaladdresshistory.FieldRegionCode, postaladdresshistory.FieldLanguageCode, postaladdresshistory.FieldPostalCode, postaladdresshistory.FieldSortingCode, postaladdresshistory.FieldAdministrativeArea, postaladdresshistory.FieldLocality, postaladdresshistory.FieldSublocality, postaladdresshistory.FieldOrganization:
			values[i] = new(sql.NullString)
		case postaladdresshistory.FieldHistoryTime, postaladdresshistory.FieldCreatedAt, postaladdresshistory.FieldUpdatedAt, postaladdresshistory.FieldDeletedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the PostalAddressHistory fields.
func (pah *PostalAddressHistory) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case postaladdresshistory.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				pah.ID = value.String
			}
		case postaladdresshistory.FieldHistoryTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field history_time", values[i])
			} else if value.Valid {
				pah.HistoryTime = value.Time
			}
		case postaladdresshistory.FieldRef:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ref", values[i])
			} else if value.Valid {
				pah.Ref = value.String
			}
		case postaladdresshistory.FieldOperation:
			if value, ok := values[i].(*enthistory.OpType); !ok {
				return fmt.Errorf("unexpected type %T for field operation", values[i])
			} else if value != nil {
				pah.Operation = *value
			}
		case postaladdresshistory.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				pah.CreatedAt = value.Time
			}
		case postaladdresshistory.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				pah.UpdatedAt = value.Time
			}
		case postaladdresshistory.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				pah.CreatedBy = value.String
			}
		case postaladdresshistory.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				pah.UpdatedBy = value.String
			}
		case postaladdresshistory.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				pah.DeletedAt = new(time.Time)
				*pah.DeletedAt = value.Time
			}
		case postaladdresshistory.FieldDeletedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_by", values[i])
			} else if value.Valid {
				pah.DeletedBy = new(string)
				*pah.DeletedBy = value.String
			}
		case postaladdresshistory.FieldMappingID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mapping_id", values[i])
			} else if value.Valid {
				pah.MappingID = value.String
			}
		case postaladdresshistory.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &pah.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case postaladdresshistory.FieldOwnerID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field owner_id", values[i])
			} else if value.Valid {
				pah.OwnerID = value.String
			}
		case postaladdresshistory.FieldRegionCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region_code", values[i])
			} else if value.Valid {
				pah.RegionCode = value.String
			}
		case postaladdresshistory.FieldLanguageCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field language_code", values[i])
			} else if value.Valid {
				pah.LanguageCode = new(string)
				*pah.LanguageCode = value.String
			}
		case postaladdresshistory.FieldPostalCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field postal_code", values[i])
			} else if value.Valid {
				pah.PostalCode = new(string)
				*pah.PostalCode = value.String
			}
		case postaladdresshistory.FieldSortingCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sorting_code", values[i])
			} else if value.Valid {
				pah.SortingCode = new(string)
				*pah.SortingCode = value.String
			}
		case postaladdresshistory.FieldAdministrativeArea:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field administrative_area", values[i])
			} else if value.Valid {
				pah.AdministrativeArea = new(string)
				*pah.AdministrativeArea = value.String
			}
		case postaladdresshistory.FieldLocality:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field locality", values[i])
			} else if value.Valid {
				pah.Locality = new(string)
				*pah.Locality = value.String
			}
		case postaladdresshistory.FieldSublocality:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sublocality", values[i])
			} else if value.Valid {
				pah.Sublocality = new(string)
				*pah.Sublocality = value.String
			}
		case postaladdresshistory.FieldAddressLines:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field address_lines", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &pah.AddressLines); err != nil {
					return fmt.Errorf("unmarshal field address_lines: %w", err)
				}
			}
		case postaladdresshistory.FieldRecipients:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field recipients", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &pah.Recipients); err != nil {
					return fmt.Errorf("unmarshal field recipients: %w", err)
				}
			}
		case postaladdresshistory.FieldOrganization:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field organization", values[i])
			} else if value.Valid {
				pah.Organization = new(string)
				*pah.Organization = value.String
			}
		default:
			pah.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the PostalAddressHistory.
// This includes values selected through modifiers, order, etc.
func (pah *PostalAddressHistory) Value(name string) (ent.Value, error) {
	return pah.selectValues.Get(name)
}

// Update returns a builder for updating this PostalAddressHistory.
// Note that you need to call PostalAddressHistory.Unwrap() before calling this method if this PostalAddressHistory
// was returned from a transaction, and the transaction was committed or rolled back.
func (pah *PostalAddressHistory) Update() *PostalAddressHistoryUpdateOne {
	return NewPostalAddressHistoryClient(pah.config).UpdateOne(pah)
}

// Unwrap unwraps the PostalAddressHistory entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pah *PostalAddressHistory) Unwrap() *PostalAddressHistory {
	_tx, ok := pah.config.driver.(*txDriver)
	if !ok {
		panic("generated: PostalAddressHistory is not a transactional entity")
	}
	pah.config.driver = _tx.drv
	return pah
}

// String implements the fmt.Stringer.
func (pah *PostalAddressHistory) String() string {
	var builder strings.Builder
	builder.WriteString("PostalAddressHistory(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pah.ID))
	builder.WriteString("history_time=")
	builder.WriteString(pah.HistoryTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("ref=")
	builder.WriteString(pah.Ref)
	builder.WriteString(", ")
	builder.WriteString("operation=")
	builder.WriteString(fmt.Sprintf("%v", pah.Operation))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(pah.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(pah.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(pah.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(pah.UpdatedBy)
	builder.WriteString(", ")
	if v := pah.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := pah.DeletedBy; v != nil {
		builder.WriteString("deleted_by=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("mapping_id=")
	builder.WriteString(pah.MappingID)
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", pah.Tags))
	builder.WriteString(", ")
	builder.WriteString("owner_id=")
	builder.WriteString(pah.OwnerID)
	builder.WriteString(", ")
	builder.WriteString("region_code=")
	builder.WriteString(pah.RegionCode)
	builder.WriteString(", ")
	if v := pah.LanguageCode; v != nil {
		builder.WriteString("language_code=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pah.PostalCode; v != nil {
		builder.WriteString("postal_code=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pah.SortingCode; v != nil {
		builder.WriteString("sorting_code=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pah.AdministrativeArea; v != nil {
		builder.WriteString("administrative_area=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pah.Locality; v != nil {
		builder.WriteString("locality=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pah.Sublocality; v != nil {
		builder.WriteString("sublocality=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("address_lines=")
	builder.WriteString(fmt.Sprintf("%v", pah.AddressLines))
	builder.WriteString(", ")
	builder.WriteString("recipients=")
	builder.WriteString(fmt.Sprintf("%v", pah.Recipients))
	builder.WriteString(", ")
	if v := pah.Organization; v != nil {
		builder.WriteString("organization=")
		builder.WriteString(*v)
	}
	builder.WriteByte(')')
	return builder.String()
}

// PostalAddressHistories is a parsable slice of PostalAddressHistory.
type PostalAddressHistories []*PostalAddressHistory
