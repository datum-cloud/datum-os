// Code generated by enthistory, DO NOT EDIT.

// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent"
	"github.com/datum-cloud/datum-os/pkg/enthistory"
	"github.com/datum-cloud/datum-os/pkg/entx"
)

var (
	idNotFoundError = errors.New("could not get id from mutation")
)

func EntOpToHistoryOp(op ent.Op) enthistory.OpType {
	switch op {
	case ent.OpDelete, ent.OpDeleteOne:
		return enthistory.OpTypeDelete
	case ent.OpUpdate, ent.OpUpdateOne:
		return enthistory.OpTypeUpdate
	default:
		return enthistory.OpTypeInsert
	}
}

func (m *ContactMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ContactHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if fullName, exists := m.FullName(); exists {
		create = create.SetFullName(fullName)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if company, exists := m.Company(); exists {
		create = create.SetCompany(company)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if phoneNumber, exists := m.PhoneNumber(); exists {
		create = create.SetPhoneNumber(phoneNumber)
	}

	if address, exists := m.Address(); exists {
		create = create.SetAddress(address)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ContactMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contact, err := client.Contact.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(contact.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(contact.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(contact.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(contact.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(contact.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(contact.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(contact.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(contact.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(contact.OwnerID)
		}

		if fullName, exists := m.FullName(); exists {
			create = create.SetFullName(fullName)
		} else {
			create = create.SetFullName(contact.FullName)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(contact.Title)
		}

		if company, exists := m.Company(); exists {
			create = create.SetCompany(company)
		} else {
			create = create.SetCompany(contact.Company)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(contact.Email)
		}

		if phoneNumber, exists := m.PhoneNumber(); exists {
			create = create.SetPhoneNumber(phoneNumber)
		} else {
			create = create.SetPhoneNumber(contact.PhoneNumber)
		}

		if address, exists := m.Address(); exists {
			create = create.SetAddress(address)
		} else {
			create = create.SetAddress(contact.Address)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(contact.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contact, err := client.Contact.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(contact.CreatedAt).
			SetUpdatedAt(contact.UpdatedAt).
			SetCreatedBy(contact.CreatedBy).
			SetUpdatedBy(contact.UpdatedBy).
			SetMappingID(contact.MappingID).
			SetNillableDeletedAt(contact.DeletedAt).
			SetNillableDeletedBy(contact.DeletedBy).
			SetTags(contact.Tags).
			SetOwnerID(contact.OwnerID).
			SetFullName(contact.FullName).
			SetTitle(contact.Title).
			SetCompany(contact.Company).
			SetEmail(contact.Email).
			SetPhoneNumber(contact.PhoneNumber).
			SetAddress(contact.Address).
			SetStatus(contact.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactListMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ContactListHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if visibility, exists := m.Visibility(); exists {
		create = create.SetVisibility(visibility)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ContactListMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contactlist, err := client.ContactList.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactListHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(contactlist.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(contactlist.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(contactlist.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(contactlist.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(contactlist.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(contactlist.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(contactlist.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(contactlist.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(contactlist.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(contactlist.Name)
		}

		if visibility, exists := m.Visibility(); exists {
			create = create.SetVisibility(visibility)
		} else {
			create = create.SetVisibility(contactlist.Visibility)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(contactlist.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(contactlist.Description)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactListMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contactlist, err := client.ContactList.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactListHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(contactlist.CreatedAt).
			SetUpdatedAt(contactlist.UpdatedAt).
			SetCreatedBy(contactlist.CreatedBy).
			SetUpdatedBy(contactlist.UpdatedBy).
			SetNillableDeletedAt(contactlist.DeletedAt).
			SetNillableDeletedBy(contactlist.DeletedBy).
			SetMappingID(contactlist.MappingID).
			SetTags(contactlist.Tags).
			SetOwnerID(contactlist.OwnerID).
			SetName(contactlist.Name).
			SetVisibility(contactlist.Visibility).
			SetDisplayName(contactlist.DisplayName).
			SetDescription(contactlist.Description).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactListMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ContactListMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if contactListID, exists := m.ContactListID(); exists {
		create = create.SetContactListID(contactListID)
	}

	if contactID, exists := m.ContactID(); exists {
		create = create.SetContactID(contactID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ContactListMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contactlistmembership, err := client.ContactListMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactListMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(contactlistmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(contactlistmembership.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(contactlistmembership.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(contactlistmembership.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(contactlistmembership.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(contactlistmembership.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(contactlistmembership.DeletedBy)
		}

		if contactListID, exists := m.ContactListID(); exists {
			create = create.SetContactListID(contactListID)
		} else {
			create = create.SetContactListID(contactlistmembership.ContactListID)
		}

		if contactID, exists := m.ContactID(); exists {
			create = create.SetContactID(contactID)
		} else {
			create = create.SetContactID(contactlistmembership.ContactID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactListMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contactlistmembership, err := client.ContactListMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactListMembershipHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(contactlistmembership.CreatedAt).
			SetUpdatedAt(contactlistmembership.UpdatedAt).
			SetCreatedBy(contactlistmembership.CreatedBy).
			SetUpdatedBy(contactlistmembership.UpdatedBy).
			SetMappingID(contactlistmembership.MappingID).
			SetNillableDeletedAt(contactlistmembership.DeletedAt).
			SetNillableDeletedBy(contactlistmembership.DeletedBy).
			SetContactListID(contactlistmembership.ContactListID).
			SetContactID(contactlistmembership.ContactID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *DocumentDataMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.DocumentDataHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if templateID, exists := m.TemplateID(); exists {
		create = create.SetTemplateID(templateID)
	}

	if data, exists := m.Data(); exists {
		create = create.SetData(data)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *DocumentDataMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		documentdata, err := client.DocumentData.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DocumentDataHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(documentdata.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(documentdata.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(documentdata.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(documentdata.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(documentdata.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(documentdata.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(documentdata.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(documentdata.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(documentdata.OwnerID)
		}

		if templateID, exists := m.TemplateID(); exists {
			create = create.SetTemplateID(templateID)
		} else {
			create = create.SetTemplateID(documentdata.TemplateID)
		}

		if data, exists := m.Data(); exists {
			create = create.SetData(data)
		} else {
			create = create.SetData(documentdata.Data)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *DocumentDataMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		documentdata, err := client.DocumentData.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DocumentDataHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(documentdata.CreatedAt).
			SetUpdatedAt(documentdata.UpdatedAt).
			SetCreatedBy(documentdata.CreatedBy).
			SetUpdatedBy(documentdata.UpdatedBy).
			SetMappingID(documentdata.MappingID).
			SetTags(documentdata.Tags).
			SetNillableDeletedAt(documentdata.DeletedAt).
			SetNillableDeletedBy(documentdata.DeletedBy).
			SetOwnerID(documentdata.OwnerID).
			SetTemplateID(documentdata.TemplateID).
			SetData(documentdata.Data).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntitlementMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntitlementHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if planID, exists := m.PlanID(); exists {
		create = create.SetPlanID(planID)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	if externalCustomerID, exists := m.ExternalCustomerID(); exists {
		create = create.SetExternalCustomerID(externalCustomerID)
	}

	if externalSubscriptionID, exists := m.ExternalSubscriptionID(); exists {
		create = create.SetExternalSubscriptionID(externalSubscriptionID)
	}

	if expires, exists := m.Expires(); exists {
		create = create.SetExpires(expires)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetNillableExpiresAt(&expiresAt)
	}

	if cancelled, exists := m.Cancelled(); exists {
		create = create.SetCancelled(cancelled)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntitlementMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitlement, err := client.Entitlement.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntitlementHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entitlement.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entitlement.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entitlement.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entitlement.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(entitlement.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entitlement.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(entitlement.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(entitlement.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entitlement.OwnerID)
		}

		if planID, exists := m.PlanID(); exists {
			create = create.SetPlanID(planID)
		} else {
			create = create.SetPlanID(entitlement.PlanID)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(entitlement.OrganizationID)
		}

		if externalCustomerID, exists := m.ExternalCustomerID(); exists {
			create = create.SetExternalCustomerID(externalCustomerID)
		} else {
			create = create.SetExternalCustomerID(entitlement.ExternalCustomerID)
		}

		if externalSubscriptionID, exists := m.ExternalSubscriptionID(); exists {
			create = create.SetExternalSubscriptionID(externalSubscriptionID)
		} else {
			create = create.SetExternalSubscriptionID(entitlement.ExternalSubscriptionID)
		}

		if expires, exists := m.Expires(); exists {
			create = create.SetExpires(expires)
		} else {
			create = create.SetExpires(entitlement.Expires)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetNillableExpiresAt(&expiresAt)
		} else {
			create = create.SetNillableExpiresAt(entitlement.ExpiresAt)
		}

		if cancelled, exists := m.Cancelled(); exists {
			create = create.SetCancelled(cancelled)
		} else {
			create = create.SetCancelled(entitlement.Cancelled)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntitlementMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitlement, err := client.Entitlement.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntitlementHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entitlement.CreatedAt).
			SetUpdatedAt(entitlement.UpdatedAt).
			SetCreatedBy(entitlement.CreatedBy).
			SetUpdatedBy(entitlement.UpdatedBy).
			SetMappingID(entitlement.MappingID).
			SetTags(entitlement.Tags).
			SetNillableDeletedAt(entitlement.DeletedAt).
			SetNillableDeletedBy(entitlement.DeletedBy).
			SetOwnerID(entitlement.OwnerID).
			SetPlanID(entitlement.PlanID).
			SetOrganizationID(entitlement.OrganizationID).
			SetExternalCustomerID(entitlement.ExternalCustomerID).
			SetExternalSubscriptionID(entitlement.ExternalSubscriptionID).
			SetExpires(entitlement.Expires).
			SetNillableExpiresAt(entitlement.ExpiresAt).
			SetCancelled(entitlement.Cancelled).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntitlementPlanMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntitlementPlanHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntitlementPlanMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitlementplan, err := client.EntitlementPlan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntitlementPlanHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entitlementplan.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entitlementplan.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entitlementplan.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entitlementplan.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(entitlementplan.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(entitlementplan.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(entitlementplan.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entitlementplan.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entitlementplan.OwnerID)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(entitlementplan.DisplayName)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(entitlementplan.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(entitlementplan.Description)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(entitlementplan.Version)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(entitlementplan.Metadata)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntitlementPlanMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitlementplan, err := client.EntitlementPlan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntitlementPlanHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entitlementplan.CreatedAt).
			SetUpdatedAt(entitlementplan.UpdatedAt).
			SetCreatedBy(entitlementplan.CreatedBy).
			SetUpdatedBy(entitlementplan.UpdatedBy).
			SetMappingID(entitlementplan.MappingID).
			SetNillableDeletedAt(entitlementplan.DeletedAt).
			SetNillableDeletedBy(entitlementplan.DeletedBy).
			SetTags(entitlementplan.Tags).
			SetOwnerID(entitlementplan.OwnerID).
			SetDisplayName(entitlementplan.DisplayName).
			SetName(entitlementplan.Name).
			SetDescription(entitlementplan.Description).
			SetVersion(entitlementplan.Version).
			SetMetadata(entitlementplan.Metadata).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntitlementPlanFeatureMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntitlementPlanFeatureHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if planID, exists := m.PlanID(); exists {
		create = create.SetPlanID(planID)
	}

	if featureID, exists := m.FeatureID(); exists {
		create = create.SetFeatureID(featureID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntitlementPlanFeatureMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitlementplanfeature, err := client.EntitlementPlanFeature.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntitlementPlanFeatureHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entitlementplanfeature.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entitlementplanfeature.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entitlementplanfeature.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entitlementplanfeature.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(entitlementplanfeature.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(entitlementplanfeature.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(entitlementplanfeature.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entitlementplanfeature.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entitlementplanfeature.OwnerID)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(entitlementplanfeature.Metadata)
		}

		if planID, exists := m.PlanID(); exists {
			create = create.SetPlanID(planID)
		} else {
			create = create.SetPlanID(entitlementplanfeature.PlanID)
		}

		if featureID, exists := m.FeatureID(); exists {
			create = create.SetFeatureID(featureID)
		} else {
			create = create.SetFeatureID(entitlementplanfeature.FeatureID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntitlementPlanFeatureMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitlementplanfeature, err := client.EntitlementPlanFeature.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntitlementPlanFeatureHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entitlementplanfeature.CreatedAt).
			SetUpdatedAt(entitlementplanfeature.UpdatedAt).
			SetCreatedBy(entitlementplanfeature.CreatedBy).
			SetUpdatedBy(entitlementplanfeature.UpdatedBy).
			SetMappingID(entitlementplanfeature.MappingID).
			SetNillableDeletedAt(entitlementplanfeature.DeletedAt).
			SetNillableDeletedBy(entitlementplanfeature.DeletedBy).
			SetTags(entitlementplanfeature.Tags).
			SetOwnerID(entitlementplanfeature.OwnerID).
			SetMetadata(entitlementplanfeature.Metadata).
			SetPlanID(entitlementplanfeature.PlanID).
			SetFeatureID(entitlementplanfeature.FeatureID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntityHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if entityTypeID, exists := m.EntityTypeID(); exists {
		create = create.SetEntityTypeID(entityTypeID)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntityMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entity, err := client.Entity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entity.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entity.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entity.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entity.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(entity.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(entity.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(entity.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entity.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entity.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(entity.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(entity.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(entity.Description)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(entity.Domains)
		}

		if entityTypeID, exists := m.EntityTypeID(); exists {
			create = create.SetEntityTypeID(entityTypeID)
		} else {
			create = create.SetEntityTypeID(entity.EntityTypeID)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(entity.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entity, err := client.Entity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entity.CreatedAt).
			SetUpdatedAt(entity.UpdatedAt).
			SetCreatedBy(entity.CreatedBy).
			SetUpdatedBy(entity.UpdatedBy).
			SetMappingID(entity.MappingID).
			SetNillableDeletedAt(entity.DeletedAt).
			SetNillableDeletedBy(entity.DeletedBy).
			SetTags(entity.Tags).
			SetOwnerID(entity.OwnerID).
			SetName(entity.Name).
			SetDisplayName(entity.DisplayName).
			SetDescription(entity.Description).
			SetDomains(entity.Domains).
			SetEntityTypeID(entity.EntityTypeID).
			SetStatus(entity.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityTypeMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntityTypeHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntityTypeMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitytype, err := client.EntityType.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityTypeHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entitytype.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entitytype.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entitytype.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entitytype.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(entitytype.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(entitytype.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(entitytype.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entitytype.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entitytype.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(entitytype.Name)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityTypeMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitytype, err := client.EntityType.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityTypeHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entitytype.CreatedAt).
			SetUpdatedAt(entitytype.UpdatedAt).
			SetCreatedBy(entitytype.CreatedBy).
			SetUpdatedBy(entitytype.UpdatedBy).
			SetMappingID(entitytype.MappingID).
			SetNillableDeletedAt(entitytype.DeletedAt).
			SetNillableDeletedBy(entitytype.DeletedBy).
			SetTags(entitytype.Tags).
			SetOwnerID(entitytype.OwnerID).
			SetName(entitytype.Name).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EventMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EventHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if eventID, exists := m.EventID(); exists {
		create = create.SetEventID(eventID)
	}

	if correlationID, exists := m.CorrelationID(); exists {
		create = create.SetCorrelationID(correlationID)
	}

	if eventType, exists := m.EventType(); exists {
		create = create.SetEventType(eventType)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EventMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		event, err := client.Event.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EventHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(event.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(event.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(event.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(event.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(event.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(event.Tags)
		}

		if eventID, exists := m.EventID(); exists {
			create = create.SetEventID(eventID)
		} else {
			create = create.SetEventID(event.EventID)
		}

		if correlationID, exists := m.CorrelationID(); exists {
			create = create.SetCorrelationID(correlationID)
		} else {
			create = create.SetCorrelationID(event.CorrelationID)
		}

		if eventType, exists := m.EventType(); exists {
			create = create.SetEventType(eventType)
		} else {
			create = create.SetEventType(event.EventType)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(event.Metadata)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EventMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		event, err := client.Event.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EventHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(event.CreatedAt).
			SetUpdatedAt(event.UpdatedAt).
			SetCreatedBy(event.CreatedBy).
			SetUpdatedBy(event.UpdatedBy).
			SetMappingID(event.MappingID).
			SetTags(event.Tags).
			SetEventID(event.EventID).
			SetCorrelationID(event.CorrelationID).
			SetEventType(event.EventType).
			SetMetadata(event.Metadata).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *FeatureMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.FeatureHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if enabled, exists := m.Enabled(); exists {
		create = create.SetEnabled(enabled)
	}

	if description, exists := m.Description(); exists {
		create = create.SetNillableDescription(&description)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *FeatureMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		feature, err := client.Feature.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FeatureHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(feature.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(feature.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(feature.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(feature.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(feature.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(feature.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(feature.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(feature.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(feature.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(feature.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(feature.DisplayName)
		}

		if enabled, exists := m.Enabled(); exists {
			create = create.SetEnabled(enabled)
		} else {
			create = create.SetEnabled(feature.Enabled)
		}

		if description, exists := m.Description(); exists {
			create = create.SetNillableDescription(&description)
		} else {
			create = create.SetNillableDescription(feature.Description)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(feature.Metadata)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *FeatureMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		feature, err := client.Feature.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FeatureHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(feature.CreatedAt).
			SetUpdatedAt(feature.UpdatedAt).
			SetCreatedBy(feature.CreatedBy).
			SetUpdatedBy(feature.UpdatedBy).
			SetNillableDeletedAt(feature.DeletedAt).
			SetNillableDeletedBy(feature.DeletedBy).
			SetMappingID(feature.MappingID).
			SetTags(feature.Tags).
			SetOwnerID(feature.OwnerID).
			SetName(feature.Name).
			SetDisplayName(feature.DisplayName).
			SetEnabled(feature.Enabled).
			SetNillableDescription(feature.Description).
			SetMetadata(feature.Metadata).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *FileMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.FileHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if fileName, exists := m.FileName(); exists {
		create = create.SetFileName(fileName)
	}

	if fileExtension, exists := m.FileExtension(); exists {
		create = create.SetFileExtension(fileExtension)
	}

	if fileSize, exists := m.FileSize(); exists {
		create = create.SetFileSize(fileSize)
	}

	if contentType, exists := m.ContentType(); exists {
		create = create.SetContentType(contentType)
	}

	if storeKey, exists := m.StoreKey(); exists {
		create = create.SetStoreKey(storeKey)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if annotation, exists := m.Annotation(); exists {
		create = create.SetAnnotation(annotation)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *FileMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		file, err := client.File.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FileHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(file.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(file.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(file.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(file.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(file.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(file.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(file.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(file.Tags)
		}

		if fileName, exists := m.FileName(); exists {
			create = create.SetFileName(fileName)
		} else {
			create = create.SetFileName(file.FileName)
		}

		if fileExtension, exists := m.FileExtension(); exists {
			create = create.SetFileExtension(fileExtension)
		} else {
			create = create.SetFileExtension(file.FileExtension)
		}

		if fileSize, exists := m.FileSize(); exists {
			create = create.SetFileSize(fileSize)
		} else {
			create = create.SetFileSize(file.FileSize)
		}

		if contentType, exists := m.ContentType(); exists {
			create = create.SetContentType(contentType)
		} else {
			create = create.SetContentType(file.ContentType)
		}

		if storeKey, exists := m.StoreKey(); exists {
			create = create.SetStoreKey(storeKey)
		} else {
			create = create.SetStoreKey(file.StoreKey)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(file.Category)
		}

		if annotation, exists := m.Annotation(); exists {
			create = create.SetAnnotation(annotation)
		} else {
			create = create.SetAnnotation(file.Annotation)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *FileMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		file, err := client.File.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FileHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(file.CreatedAt).
			SetUpdatedAt(file.UpdatedAt).
			SetCreatedBy(file.CreatedBy).
			SetUpdatedBy(file.UpdatedBy).
			SetNillableDeletedAt(file.DeletedAt).
			SetNillableDeletedBy(file.DeletedBy).
			SetMappingID(file.MappingID).
			SetTags(file.Tags).
			SetFileName(file.FileName).
			SetFileExtension(file.FileExtension).
			SetFileSize(file.FileSize).
			SetContentType(file.ContentType).
			SetStoreKey(file.StoreKey).
			SetCategory(file.Category).
			SetAnnotation(file.Annotation).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
		create = create.SetGravatarLogoURL(gravatarLogoURL)
	}

	if logoURL, exists := m.LogoURL(); exists {
		create = create.SetLogoURL(logoURL)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(group.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(group.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(group.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(group.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(group.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(group.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(group.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(group.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(group.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(group.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(group.Description)
		}

		if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
			create = create.SetGravatarLogoURL(gravatarLogoURL)
		} else {
			create = create.SetGravatarLogoURL(group.GravatarLogoURL)
		}

		if logoURL, exists := m.LogoURL(); exists {
			create = create.SetLogoURL(logoURL)
		} else {
			create = create.SetLogoURL(group.LogoURL)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(group.DisplayName)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(group.CreatedAt).
			SetUpdatedAt(group.UpdatedAt).
			SetCreatedBy(group.CreatedBy).
			SetUpdatedBy(group.UpdatedBy).
			SetNillableDeletedAt(group.DeletedAt).
			SetNillableDeletedBy(group.DeletedBy).
			SetMappingID(group.MappingID).
			SetTags(group.Tags).
			SetOwnerID(group.OwnerID).
			SetName(group.Name).
			SetDescription(group.Description).
			SetGravatarLogoURL(group.GravatarLogoURL).
			SetLogoURL(group.LogoURL).
			SetDisplayName(group.DisplayName).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if groupID, exists := m.GroupID(); exists {
		create = create.SetGroupID(groupID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupmembership, err := client.GroupMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(groupmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(groupmembership.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(groupmembership.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(groupmembership.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(groupmembership.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(groupmembership.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(groupmembership.DeletedBy)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(groupmembership.Role)
		}

		if groupID, exists := m.GroupID(); exists {
			create = create.SetGroupID(groupID)
		} else {
			create = create.SetGroupID(groupmembership.GroupID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(groupmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupmembership, err := client.GroupMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupMembershipHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(groupmembership.CreatedAt).
			SetUpdatedAt(groupmembership.UpdatedAt).
			SetCreatedBy(groupmembership.CreatedBy).
			SetUpdatedBy(groupmembership.UpdatedBy).
			SetMappingID(groupmembership.MappingID).
			SetNillableDeletedAt(groupmembership.DeletedAt).
			SetNillableDeletedBy(groupmembership.DeletedBy).
			SetRole(groupmembership.Role).
			SetGroupID(groupmembership.GroupID).
			SetUserID(groupmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if visibility, exists := m.Visibility(); exists {
		create = create.SetVisibility(visibility)
	}

	if joinPolicy, exists := m.JoinPolicy(); exists {
		create = create.SetJoinPolicy(joinPolicy)
	}

	if syncToSlack, exists := m.SyncToSlack(); exists {
		create = create.SetSyncToSlack(syncToSlack)
	}

	if syncToGithub, exists := m.SyncToGithub(); exists {
		create = create.SetSyncToGithub(syncToGithub)
	}

	if groupID, exists := m.GroupID(); exists {
		create = create.SetGroupID(groupID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(groupsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(groupsetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(groupsetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(groupsetting.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(groupsetting.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(groupsetting.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(groupsetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(groupsetting.DeletedBy)
		}

		if visibility, exists := m.Visibility(); exists {
			create = create.SetVisibility(visibility)
		} else {
			create = create.SetVisibility(groupsetting.Visibility)
		}

		if joinPolicy, exists := m.JoinPolicy(); exists {
			create = create.SetJoinPolicy(joinPolicy)
		} else {
			create = create.SetJoinPolicy(groupsetting.JoinPolicy)
		}

		if syncToSlack, exists := m.SyncToSlack(); exists {
			create = create.SetSyncToSlack(syncToSlack)
		} else {
			create = create.SetSyncToSlack(groupsetting.SyncToSlack)
		}

		if syncToGithub, exists := m.SyncToGithub(); exists {
			create = create.SetSyncToGithub(syncToGithub)
		} else {
			create = create.SetSyncToGithub(groupsetting.SyncToGithub)
		}

		if groupID, exists := m.GroupID(); exists {
			create = create.SetGroupID(groupID)
		} else {
			create = create.SetGroupID(groupsetting.GroupID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupSettingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(groupsetting.CreatedAt).
			SetUpdatedAt(groupsetting.UpdatedAt).
			SetCreatedBy(groupsetting.CreatedBy).
			SetUpdatedBy(groupsetting.UpdatedBy).
			SetMappingID(groupsetting.MappingID).
			SetTags(groupsetting.Tags).
			SetNillableDeletedAt(groupsetting.DeletedAt).
			SetNillableDeletedBy(groupsetting.DeletedBy).
			SetVisibility(groupsetting.Visibility).
			SetJoinPolicy(groupsetting.JoinPolicy).
			SetSyncToSlack(groupsetting.SyncToSlack).
			SetSyncToGithub(groupsetting.SyncToGithub).
			SetGroupID(groupsetting.GroupID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *HushMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.HushHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	if secretName, exists := m.SecretName(); exists {
		create = create.SetSecretName(secretName)
	}

	if secretValue, exists := m.SecretValue(); exists {
		create = create.SetSecretValue(secretValue)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *HushMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		hush, err := client.Hush.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.HushHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(hush.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(hush.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(hush.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(hush.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(hush.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(hush.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(hush.DeletedBy)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(hush.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(hush.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(hush.Kind)
		}

		if secretName, exists := m.SecretName(); exists {
			create = create.SetSecretName(secretName)
		} else {
			create = create.SetSecretName(hush.SecretName)
		}

		if secretValue, exists := m.SecretValue(); exists {
			create = create.SetSecretValue(secretValue)
		} else {
			create = create.SetSecretValue(hush.SecretValue)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *HushMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		hush, err := client.Hush.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.HushHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(hush.CreatedAt).
			SetUpdatedAt(hush.UpdatedAt).
			SetCreatedBy(hush.CreatedBy).
			SetUpdatedBy(hush.UpdatedBy).
			SetMappingID(hush.MappingID).
			SetNillableDeletedAt(hush.DeletedAt).
			SetNillableDeletedBy(hush.DeletedBy).
			SetName(hush.Name).
			SetDescription(hush.Description).
			SetKind(hush.Kind).
			SetSecretName(hush.SecretName).
			SetSecretValue(hush.SecretValue).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.IntegrationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *IntegrationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.IntegrationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(integration.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(integration.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(integration.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(integration.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(integration.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(integration.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(integration.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(integration.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(integration.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(integration.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(integration.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(integration.Kind)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.IntegrationHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(integration.CreatedAt).
			SetUpdatedAt(integration.UpdatedAt).
			SetCreatedBy(integration.CreatedBy).
			SetUpdatedBy(integration.UpdatedBy).
			SetMappingID(integration.MappingID).
			SetTags(integration.Tags).
			SetNillableDeletedAt(integration.DeletedAt).
			SetNillableDeletedBy(integration.DeletedBy).
			SetOwnerID(integration.OwnerID).
			SetName(integration.Name).
			SetDescription(integration.Description).
			SetKind(integration.Kind).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *NoteMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.NoteHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if text, exists := m.Text(); exists {
		create = create.SetText(text)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *NoteMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		note, err := client.Note.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NoteHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(note.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(note.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(note.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(note.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(note.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(note.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(note.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(note.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(note.OwnerID)
		}

		if text, exists := m.Text(); exists {
			create = create.SetText(text)
		} else {
			create = create.SetText(note.Text)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *NoteMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		note, err := client.Note.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NoteHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(note.CreatedAt).
			SetUpdatedAt(note.UpdatedAt).
			SetCreatedBy(note.CreatedBy).
			SetUpdatedBy(note.UpdatedBy).
			SetMappingID(note.MappingID).
			SetNillableDeletedAt(note.DeletedAt).
			SetNillableDeletedBy(note.DeletedBy).
			SetTags(note.Tags).
			SetOwnerID(note.OwnerID).
			SetText(note.Text).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OauthProviderMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OauthProviderHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if clientID, exists := m.ClientID(); exists {
		create = create.SetClientID(clientID)
	}

	if clientSecret, exists := m.ClientSecret(); exists {
		create = create.SetClientSecret(clientSecret)
	}

	if redirectURL, exists := m.RedirectURL(); exists {
		create = create.SetRedirectURL(redirectURL)
	}

	if scopes, exists := m.Scopes(); exists {
		create = create.SetScopes(scopes)
	}

	if authURL, exists := m.AuthURL(); exists {
		create = create.SetAuthURL(authURL)
	}

	if tokenURL, exists := m.TokenURL(); exists {
		create = create.SetTokenURL(tokenURL)
	}

	if authStyle, exists := m.AuthStyle(); exists {
		create = create.SetAuthStyle(authStyle)
	}

	if infoURL, exists := m.InfoURL(); exists {
		create = create.SetInfoURL(infoURL)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OauthProviderMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		oauthprovider, err := client.OauthProvider.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OauthProviderHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(oauthprovider.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(oauthprovider.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(oauthprovider.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(oauthprovider.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(oauthprovider.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(oauthprovider.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(oauthprovider.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(oauthprovider.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(oauthprovider.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(oauthprovider.Name)
		}

		if clientID, exists := m.ClientID(); exists {
			create = create.SetClientID(clientID)
		} else {
			create = create.SetClientID(oauthprovider.ClientID)
		}

		if clientSecret, exists := m.ClientSecret(); exists {
			create = create.SetClientSecret(clientSecret)
		} else {
			create = create.SetClientSecret(oauthprovider.ClientSecret)
		}

		if redirectURL, exists := m.RedirectURL(); exists {
			create = create.SetRedirectURL(redirectURL)
		} else {
			create = create.SetRedirectURL(oauthprovider.RedirectURL)
		}

		if scopes, exists := m.Scopes(); exists {
			create = create.SetScopes(scopes)
		} else {
			create = create.SetScopes(oauthprovider.Scopes)
		}

		if authURL, exists := m.AuthURL(); exists {
			create = create.SetAuthURL(authURL)
		} else {
			create = create.SetAuthURL(oauthprovider.AuthURL)
		}

		if tokenURL, exists := m.TokenURL(); exists {
			create = create.SetTokenURL(tokenURL)
		} else {
			create = create.SetTokenURL(oauthprovider.TokenURL)
		}

		if authStyle, exists := m.AuthStyle(); exists {
			create = create.SetAuthStyle(authStyle)
		} else {
			create = create.SetAuthStyle(oauthprovider.AuthStyle)
		}

		if infoURL, exists := m.InfoURL(); exists {
			create = create.SetInfoURL(infoURL)
		} else {
			create = create.SetInfoURL(oauthprovider.InfoURL)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OauthProviderMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		oauthprovider, err := client.OauthProvider.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OauthProviderHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(oauthprovider.CreatedAt).
			SetUpdatedAt(oauthprovider.UpdatedAt).
			SetCreatedBy(oauthprovider.CreatedBy).
			SetUpdatedBy(oauthprovider.UpdatedBy).
			SetMappingID(oauthprovider.MappingID).
			SetTags(oauthprovider.Tags).
			SetNillableDeletedAt(oauthprovider.DeletedAt).
			SetNillableDeletedBy(oauthprovider.DeletedBy).
			SetOwnerID(oauthprovider.OwnerID).
			SetName(oauthprovider.Name).
			SetClientID(oauthprovider.ClientID).
			SetClientSecret(oauthprovider.ClientSecret).
			SetRedirectURL(oauthprovider.RedirectURL).
			SetScopes(oauthprovider.Scopes).
			SetAuthURL(oauthprovider.AuthURL).
			SetTokenURL(oauthprovider.TokenURL).
			SetAuthStyle(oauthprovider.AuthStyle).
			SetInfoURL(oauthprovider.InfoURL).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrgMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrgMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgmembership, err := client.OrgMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(orgmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(orgmembership.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(orgmembership.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(orgmembership.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(orgmembership.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(orgmembership.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(orgmembership.DeletedBy)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(orgmembership.Role)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(orgmembership.OrganizationID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(orgmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgmembership, err := client.OrgMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgMembershipHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(orgmembership.CreatedAt).
			SetUpdatedAt(orgmembership.UpdatedAt).
			SetCreatedBy(orgmembership.CreatedBy).
			SetUpdatedBy(orgmembership.UpdatedBy).
			SetMappingID(orgmembership.MappingID).
			SetNillableDeletedAt(orgmembership.DeletedAt).
			SetNillableDeletedBy(orgmembership.DeletedBy).
			SetRole(orgmembership.Role).
			SetOrganizationID(orgmembership.OrganizationID).
			SetUserID(orgmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrganizationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
		create = create.SetParentOrganizationID(parentOrganizationID)
	}

	if personalOrg, exists := m.PersonalOrg(); exists {
		create = create.SetPersonalOrg(personalOrg)
	}

	if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
		create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
	}

	if dedicatedDb, exists := m.DedicatedDb(); exists {
		create = create.SetDedicatedDb(dedicatedDb)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrganizationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organization.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organization.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(organization.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(organization.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(organization.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(organization.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(organization.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(organization.DeletedBy)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(organization.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(organization.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(organization.Description)
		}

		if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
			create = create.SetParentOrganizationID(parentOrganizationID)
		} else {
			create = create.SetParentOrganizationID(organization.ParentOrganizationID)
		}

		if personalOrg, exists := m.PersonalOrg(); exists {
			create = create.SetPersonalOrg(personalOrg)
		} else {
			create = create.SetPersonalOrg(organization.PersonalOrg)
		}

		if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
			create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
		} else {
			create = create.SetNillableAvatarRemoteURL(organization.AvatarRemoteURL)
		}

		if dedicatedDb, exists := m.DedicatedDb(); exists {
			create = create.SetDedicatedDb(dedicatedDb)
		} else {
			create = create.SetDedicatedDb(organization.DedicatedDb)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organization.CreatedAt).
			SetUpdatedAt(organization.UpdatedAt).
			SetCreatedBy(organization.CreatedBy).
			SetUpdatedBy(organization.UpdatedBy).
			SetMappingID(organization.MappingID).
			SetTags(organization.Tags).
			SetNillableDeletedAt(organization.DeletedAt).
			SetNillableDeletedBy(organization.DeletedBy).
			SetName(organization.Name).
			SetDisplayName(organization.DisplayName).
			SetDescription(organization.Description).
			SetParentOrganizationID(organization.ParentOrganizationID).
			SetPersonalOrg(organization.PersonalOrg).
			SetNillableAvatarRemoteURL(organization.AvatarRemoteURL).
			SetDedicatedDb(organization.DedicatedDb).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrganizationSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if billingContact, exists := m.BillingContact(); exists {
		create = create.SetBillingContact(billingContact)
	}

	if billingEmail, exists := m.BillingEmail(); exists {
		create = create.SetBillingEmail(billingEmail)
	}

	if billingPhone, exists := m.BillingPhone(); exists {
		create = create.SetBillingPhone(billingPhone)
	}

	if billingAddress, exists := m.BillingAddress(); exists {
		create = create.SetBillingAddress(billingAddress)
	}

	if taxIdentifier, exists := m.TaxIdentifier(); exists {
		create = create.SetTaxIdentifier(taxIdentifier)
	}

	if geoLocation, exists := m.GeoLocation(); exists {
		create = create.SetGeoLocation(geoLocation)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrganizationSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organizationsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organizationsetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(organizationsetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(organizationsetting.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(organizationsetting.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(organizationsetting.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(organizationsetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(organizationsetting.DeletedBy)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(organizationsetting.Domains)
		}

		if billingContact, exists := m.BillingContact(); exists {
			create = create.SetBillingContact(billingContact)
		} else {
			create = create.SetBillingContact(organizationsetting.BillingContact)
		}

		if billingEmail, exists := m.BillingEmail(); exists {
			create = create.SetBillingEmail(billingEmail)
		} else {
			create = create.SetBillingEmail(organizationsetting.BillingEmail)
		}

		if billingPhone, exists := m.BillingPhone(); exists {
			create = create.SetBillingPhone(billingPhone)
		} else {
			create = create.SetBillingPhone(organizationsetting.BillingPhone)
		}

		if billingAddress, exists := m.BillingAddress(); exists {
			create = create.SetBillingAddress(billingAddress)
		} else {
			create = create.SetBillingAddress(organizationsetting.BillingAddress)
		}

		if taxIdentifier, exists := m.TaxIdentifier(); exists {
			create = create.SetTaxIdentifier(taxIdentifier)
		} else {
			create = create.SetTaxIdentifier(organizationsetting.TaxIdentifier)
		}

		if geoLocation, exists := m.GeoLocation(); exists {
			create = create.SetGeoLocation(geoLocation)
		} else {
			create = create.SetGeoLocation(organizationsetting.GeoLocation)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(organizationsetting.OrganizationID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationSettingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organizationsetting.CreatedAt).
			SetUpdatedAt(organizationsetting.UpdatedAt).
			SetCreatedBy(organizationsetting.CreatedBy).
			SetUpdatedBy(organizationsetting.UpdatedBy).
			SetMappingID(organizationsetting.MappingID).
			SetTags(organizationsetting.Tags).
			SetNillableDeletedAt(organizationsetting.DeletedAt).
			SetNillableDeletedBy(organizationsetting.DeletedBy).
			SetDomains(organizationsetting.Domains).
			SetBillingContact(organizationsetting.BillingContact).
			SetBillingEmail(organizationsetting.BillingEmail).
			SetBillingPhone(organizationsetting.BillingPhone).
			SetBillingAddress(organizationsetting.BillingAddress).
			SetTaxIdentifier(organizationsetting.TaxIdentifier).
			SetGeoLocation(organizationsetting.GeoLocation).
			SetOrganizationID(organizationsetting.OrganizationID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *PhoneNumberMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.PhoneNumberHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	if regionCode, exists := m.RegionCode(); exists {
		create = create.SetRegionCode(regionCode)
	}

	if shortCode, exists := m.ShortCode(); exists {
		create = create.SetShortCode(shortCode)
	}

	if number, exists := m.Number(); exists {
		create = create.SetNumber(number)
	}

	if extension, exists := m.Extension(); exists {
		create = create.SetExtension(extension)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *PhoneNumberMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		phonenumber, err := client.PhoneNumber.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.PhoneNumberHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(phonenumber.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(phonenumber.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(phonenumber.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(phonenumber.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(phonenumber.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(phonenumber.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(phonenumber.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(phonenumber.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(phonenumber.OwnerID)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(phonenumber.Kind)
		}

		if regionCode, exists := m.RegionCode(); exists {
			create = create.SetRegionCode(regionCode)
		} else {
			create = create.SetRegionCode(phonenumber.RegionCode)
		}

		if shortCode, exists := m.ShortCode(); exists {
			create = create.SetShortCode(shortCode)
		} else {
			create = create.SetShortCode(phonenumber.ShortCode)
		}

		if number, exists := m.Number(); exists {
			create = create.SetNumber(number)
		} else {
			create = create.SetNumber(phonenumber.Number)
		}

		if extension, exists := m.Extension(); exists {
			create = create.SetExtension(extension)
		} else {
			create = create.SetExtension(phonenumber.Extension)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *PhoneNumberMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		phonenumber, err := client.PhoneNumber.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.PhoneNumberHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(phonenumber.CreatedAt).
			SetUpdatedAt(phonenumber.UpdatedAt).
			SetCreatedBy(phonenumber.CreatedBy).
			SetUpdatedBy(phonenumber.UpdatedBy).
			SetNillableDeletedAt(phonenumber.DeletedAt).
			SetNillableDeletedBy(phonenumber.DeletedBy).
			SetMappingID(phonenumber.MappingID).
			SetTags(phonenumber.Tags).
			SetOwnerID(phonenumber.OwnerID).
			SetKind(phonenumber.Kind).
			SetRegionCode(phonenumber.RegionCode).
			SetShortCode(phonenumber.ShortCode).
			SetNumber(phonenumber.Number).
			SetExtension(phonenumber.Extension).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *PostalAddressMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.PostalAddressHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if regionCode, exists := m.RegionCode(); exists {
		create = create.SetRegionCode(regionCode)
	}

	if languageCode, exists := m.LanguageCode(); exists {
		create = create.SetNillableLanguageCode(&languageCode)
	}

	if postalCode, exists := m.PostalCode(); exists {
		create = create.SetNillablePostalCode(&postalCode)
	}

	if sortingCode, exists := m.SortingCode(); exists {
		create = create.SetNillableSortingCode(&sortingCode)
	}

	if administrativeArea, exists := m.AdministrativeArea(); exists {
		create = create.SetNillableAdministrativeArea(&administrativeArea)
	}

	if locality, exists := m.Locality(); exists {
		create = create.SetNillableLocality(&locality)
	}

	if sublocality, exists := m.Sublocality(); exists {
		create = create.SetNillableSublocality(&sublocality)
	}

	if addressLines, exists := m.AddressLines(); exists {
		create = create.SetAddressLines(addressLines)
	}

	if recipients, exists := m.Recipients(); exists {
		create = create.SetRecipients(recipients)
	}

	if organization, exists := m.Organization(); exists {
		create = create.SetNillableOrganization(&organization)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *PostalAddressMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		postaladdress, err := client.PostalAddress.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.PostalAddressHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(postaladdress.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(postaladdress.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(postaladdress.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(postaladdress.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(postaladdress.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(postaladdress.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(postaladdress.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(postaladdress.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(postaladdress.OwnerID)
		}

		if regionCode, exists := m.RegionCode(); exists {
			create = create.SetRegionCode(regionCode)
		} else {
			create = create.SetRegionCode(postaladdress.RegionCode)
		}

		if languageCode, exists := m.LanguageCode(); exists {
			create = create.SetNillableLanguageCode(&languageCode)
		} else {
			create = create.SetNillableLanguageCode(postaladdress.LanguageCode)
		}

		if postalCode, exists := m.PostalCode(); exists {
			create = create.SetNillablePostalCode(&postalCode)
		} else {
			create = create.SetNillablePostalCode(postaladdress.PostalCode)
		}

		if sortingCode, exists := m.SortingCode(); exists {
			create = create.SetNillableSortingCode(&sortingCode)
		} else {
			create = create.SetNillableSortingCode(postaladdress.SortingCode)
		}

		if administrativeArea, exists := m.AdministrativeArea(); exists {
			create = create.SetNillableAdministrativeArea(&administrativeArea)
		} else {
			create = create.SetNillableAdministrativeArea(postaladdress.AdministrativeArea)
		}

		if locality, exists := m.Locality(); exists {
			create = create.SetNillableLocality(&locality)
		} else {
			create = create.SetNillableLocality(postaladdress.Locality)
		}

		if sublocality, exists := m.Sublocality(); exists {
			create = create.SetNillableSublocality(&sublocality)
		} else {
			create = create.SetNillableSublocality(postaladdress.Sublocality)
		}

		if addressLines, exists := m.AddressLines(); exists {
			create = create.SetAddressLines(addressLines)
		} else {
			create = create.SetAddressLines(postaladdress.AddressLines)
		}

		if recipients, exists := m.Recipients(); exists {
			create = create.SetRecipients(recipients)
		} else {
			create = create.SetRecipients(postaladdress.Recipients)
		}

		if organization, exists := m.Organization(); exists {
			create = create.SetNillableOrganization(&organization)
		} else {
			create = create.SetNillableOrganization(postaladdress.Organization)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *PostalAddressMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		postaladdress, err := client.PostalAddress.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.PostalAddressHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(postaladdress.CreatedAt).
			SetUpdatedAt(postaladdress.UpdatedAt).
			SetCreatedBy(postaladdress.CreatedBy).
			SetUpdatedBy(postaladdress.UpdatedBy).
			SetNillableDeletedAt(postaladdress.DeletedAt).
			SetNillableDeletedBy(postaladdress.DeletedBy).
			SetMappingID(postaladdress.MappingID).
			SetTags(postaladdress.Tags).
			SetOwnerID(postaladdress.OwnerID).
			SetRegionCode(postaladdress.RegionCode).
			SetNillableLanguageCode(postaladdress.LanguageCode).
			SetNillablePostalCode(postaladdress.PostalCode).
			SetNillableSortingCode(postaladdress.SortingCode).
			SetNillableAdministrativeArea(postaladdress.AdministrativeArea).
			SetNillableLocality(postaladdress.Locality).
			SetNillableSublocality(postaladdress.Sublocality).
			SetAddressLines(postaladdress.AddressLines).
			SetRecipients(postaladdress.Recipients).
			SetNillableOrganization(postaladdress.Organization).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TemplateMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TemplateHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if templateType, exists := m.TemplateType(); exists {
		create = create.SetTemplateType(templateType)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if jsonconfig, exists := m.Jsonconfig(); exists {
		create = create.SetJsonconfig(jsonconfig)
	}

	if uischema, exists := m.Uischema(); exists {
		create = create.SetUischema(uischema)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TemplateMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		template, err := client.Template.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TemplateHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(template.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(template.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(template.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(template.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(template.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(template.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(template.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(template.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(template.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(template.Name)
		}

		if templateType, exists := m.TemplateType(); exists {
			create = create.SetTemplateType(templateType)
		} else {
			create = create.SetTemplateType(template.TemplateType)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(template.Description)
		}

		if jsonconfig, exists := m.Jsonconfig(); exists {
			create = create.SetJsonconfig(jsonconfig)
		} else {
			create = create.SetJsonconfig(template.Jsonconfig)
		}

		if uischema, exists := m.Uischema(); exists {
			create = create.SetUischema(uischema)
		} else {
			create = create.SetUischema(template.Uischema)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TemplateMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		template, err := client.Template.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TemplateHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(template.CreatedAt).
			SetUpdatedAt(template.UpdatedAt).
			SetCreatedBy(template.CreatedBy).
			SetUpdatedBy(template.UpdatedBy).
			SetNillableDeletedAt(template.DeletedAt).
			SetNillableDeletedBy(template.DeletedBy).
			SetMappingID(template.MappingID).
			SetTags(template.Tags).
			SetOwnerID(template.OwnerID).
			SetName(template.Name).
			SetTemplateType(template.TemplateType).
			SetDescription(template.Description).
			SetJsonconfig(template.Jsonconfig).
			SetUischema(template.Uischema).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.UserHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if firstName, exists := m.FirstName(); exists {
		create = create.SetFirstName(firstName)
	}

	if lastName, exists := m.LastName(); exists {
		create = create.SetLastName(lastName)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
		create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
	}

	if avatarLocalFile, exists := m.AvatarLocalFile(); exists {
		create = create.SetNillableAvatarLocalFile(&avatarLocalFile)
	}

	if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
		create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
	}

	if lastSeen, exists := m.LastSeen(); exists {
		create = create.SetNillableLastSeen(&lastSeen)
	}

	if password, exists := m.Password(); exists {
		create = create.SetNillablePassword(&password)
	}

	if sub, exists := m.Sub(); exists {
		create = create.SetSub(sub)
	}

	if authProvider, exists := m.AuthProvider(); exists {
		create = create.SetAuthProvider(authProvider)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *UserMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(user.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(user.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(user.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(user.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(user.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(user.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(user.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(user.Tags)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(user.Email)
		}

		if firstName, exists := m.FirstName(); exists {
			create = create.SetFirstName(firstName)
		} else {
			create = create.SetFirstName(user.FirstName)
		}

		if lastName, exists := m.LastName(); exists {
			create = create.SetLastName(lastName)
		} else {
			create = create.SetLastName(user.LastName)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(user.DisplayName)
		}

		if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
			create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
		} else {
			create = create.SetNillableAvatarRemoteURL(user.AvatarRemoteURL)
		}

		if avatarLocalFile, exists := m.AvatarLocalFile(); exists {
			create = create.SetNillableAvatarLocalFile(&avatarLocalFile)
		} else {
			create = create.SetNillableAvatarLocalFile(user.AvatarLocalFile)
		}

		if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
			create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
		} else {
			create = create.SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt)
		}

		if lastSeen, exists := m.LastSeen(); exists {
			create = create.SetNillableLastSeen(&lastSeen)
		} else {
			create = create.SetNillableLastSeen(user.LastSeen)
		}

		if password, exists := m.Password(); exists {
			create = create.SetNillablePassword(&password)
		} else {
			create = create.SetNillablePassword(user.Password)
		}

		if sub, exists := m.Sub(); exists {
			create = create.SetSub(sub)
		} else {
			create = create.SetSub(user.Sub)
		}

		if authProvider, exists := m.AuthProvider(); exists {
			create = create.SetAuthProvider(authProvider)
		} else {
			create = create.SetAuthProvider(user.AuthProvider)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(user.Role)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(user.CreatedAt).
			SetUpdatedAt(user.UpdatedAt).
			SetCreatedBy(user.CreatedBy).
			SetUpdatedBy(user.UpdatedBy).
			SetNillableDeletedAt(user.DeletedAt).
			SetNillableDeletedBy(user.DeletedBy).
			SetMappingID(user.MappingID).
			SetTags(user.Tags).
			SetEmail(user.Email).
			SetFirstName(user.FirstName).
			SetLastName(user.LastName).
			SetDisplayName(user.DisplayName).
			SetNillableAvatarRemoteURL(user.AvatarRemoteURL).
			SetNillableAvatarLocalFile(user.AvatarLocalFile).
			SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt).
			SetNillableLastSeen(user.LastSeen).
			SetNillablePassword(user.Password).
			SetSub(user.Sub).
			SetAuthProvider(user.AuthProvider).
			SetRole(user.Role).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.UserSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	if locked, exists := m.Locked(); exists {
		create = create.SetLocked(locked)
	}

	if silencedAt, exists := m.SilencedAt(); exists {
		create = create.SetNillableSilencedAt(&silencedAt)
	}

	if suspendedAt, exists := m.SuspendedAt(); exists {
		create = create.SetNillableSuspendedAt(&suspendedAt)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if emailConfirmed, exists := m.EmailConfirmed(); exists {
		create = create.SetEmailConfirmed(emailConfirmed)
	}

	if isWebauthnAllowed, exists := m.IsWebauthnAllowed(); exists {
		create = create.SetIsWebauthnAllowed(isWebauthnAllowed)
	}

	if isTfaEnabled, exists := m.IsTfaEnabled(); exists {
		create = create.SetIsTfaEnabled(isTfaEnabled)
	}

	if phoneNumber, exists := m.PhoneNumber(); exists {
		create = create.SetNillablePhoneNumber(&phoneNumber)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *UserSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(usersetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(usersetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(usersetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(usersetting.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(usersetting.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(usersetting.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(usersetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(usersetting.DeletedBy)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(usersetting.UserID)
		}

		if locked, exists := m.Locked(); exists {
			create = create.SetLocked(locked)
		} else {
			create = create.SetLocked(usersetting.Locked)
		}

		if silencedAt, exists := m.SilencedAt(); exists {
			create = create.SetNillableSilencedAt(&silencedAt)
		} else {
			create = create.SetNillableSilencedAt(usersetting.SilencedAt)
		}

		if suspendedAt, exists := m.SuspendedAt(); exists {
			create = create.SetNillableSuspendedAt(&suspendedAt)
		} else {
			create = create.SetNillableSuspendedAt(usersetting.SuspendedAt)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(usersetting.Status)
		}

		if emailConfirmed, exists := m.EmailConfirmed(); exists {
			create = create.SetEmailConfirmed(emailConfirmed)
		} else {
			create = create.SetEmailConfirmed(usersetting.EmailConfirmed)
		}

		if isWebauthnAllowed, exists := m.IsWebauthnAllowed(); exists {
			create = create.SetIsWebauthnAllowed(isWebauthnAllowed)
		} else {
			create = create.SetIsWebauthnAllowed(usersetting.IsWebauthnAllowed)
		}

		if isTfaEnabled, exists := m.IsTfaEnabled(); exists {
			create = create.SetIsTfaEnabled(isTfaEnabled)
		} else {
			create = create.SetIsTfaEnabled(usersetting.IsTfaEnabled)
		}

		if phoneNumber, exists := m.PhoneNumber(); exists {
			create = create.SetNillablePhoneNumber(&phoneNumber)
		} else {
			create = create.SetNillablePhoneNumber(usersetting.PhoneNumber)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserSettingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(usersetting.CreatedAt).
			SetUpdatedAt(usersetting.UpdatedAt).
			SetCreatedBy(usersetting.CreatedBy).
			SetUpdatedBy(usersetting.UpdatedBy).
			SetMappingID(usersetting.MappingID).
			SetTags(usersetting.Tags).
			SetNillableDeletedAt(usersetting.DeletedAt).
			SetNillableDeletedBy(usersetting.DeletedBy).
			SetUserID(usersetting.UserID).
			SetLocked(usersetting.Locked).
			SetNillableSilencedAt(usersetting.SilencedAt).
			SetNillableSuspendedAt(usersetting.SuspendedAt).
			SetStatus(usersetting.Status).
			SetEmailConfirmed(usersetting.EmailConfirmed).
			SetIsWebauthnAllowed(usersetting.IsWebauthnAllowed).
			SetIsTfaEnabled(usersetting.IsTfaEnabled).
			SetNillablePhoneNumber(usersetting.PhoneNumber).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.VendorHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if vendorType, exists := m.VendorType(); exists {
		create = create.SetVendorType(vendorType)
	}

	if onboardingState, exists := m.OnboardingState(); exists {
		create = create.SetOnboardingState(onboardingState)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *VendorMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendor, err := client.Vendor.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(vendor.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(vendor.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(vendor.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(vendor.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(vendor.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(vendor.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(vendor.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(vendor.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(vendor.OwnerID)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(vendor.DisplayName)
		}

		if vendorType, exists := m.VendorType(); exists {
			create = create.SetVendorType(vendorType)
		} else {
			create = create.SetVendorType(vendor.VendorType)
		}

		if onboardingState, exists := m.OnboardingState(); exists {
			create = create.SetOnboardingState(onboardingState)
		} else {
			create = create.SetOnboardingState(vendor.OnboardingState)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendor, err := client.Vendor.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(vendor.CreatedAt).
			SetUpdatedAt(vendor.UpdatedAt).
			SetCreatedBy(vendor.CreatedBy).
			SetUpdatedBy(vendor.UpdatedBy).
			SetNillableDeletedAt(vendor.DeletedAt).
			SetNillableDeletedBy(vendor.DeletedBy).
			SetMappingID(vendor.MappingID).
			SetTags(vendor.Tags).
			SetOwnerID(vendor.OwnerID).
			SetDisplayName(vendor.DisplayName).
			SetVendorType(vendor.VendorType).
			SetOnboardingState(vendor.OnboardingState).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfileMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.VendorProfileHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if vendorID, exists := m.VendorID(); exists {
		create = create.SetVendorID(vendorID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if corporationType, exists := m.CorporationType(); exists {
		create = create.SetCorporationType(corporationType)
	}

	if corporationDba, exists := m.CorporationDba(); exists {
		create = create.SetCorporationDba(corporationDba)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if websiteURI, exists := m.WebsiteURI(); exists {
		create = create.SetWebsiteURI(websiteURI)
	}

	if taxID, exists := m.TaxID(); exists {
		create = create.SetTaxID(taxID)
	}

	if taxIDType, exists := m.TaxIDType(); exists {
		create = create.SetTaxIDType(taxIDType)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *VendorProfileMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofile, err := client.VendorProfile.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfileHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(vendorprofile.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(vendorprofile.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(vendorprofile.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(vendorprofile.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(vendorprofile.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(vendorprofile.DeletedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(vendorprofile.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(vendorprofile.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(vendorprofile.OwnerID)
		}

		if vendorID, exists := m.VendorID(); exists {
			create = create.SetVendorID(vendorID)
		} else {
			create = create.SetVendorID(vendorprofile.VendorID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(vendorprofile.Name)
		}

		if corporationType, exists := m.CorporationType(); exists {
			create = create.SetCorporationType(corporationType)
		} else {
			create = create.SetCorporationType(vendorprofile.CorporationType)
		}

		if corporationDba, exists := m.CorporationDba(); exists {
			create = create.SetCorporationDba(corporationDba)
		} else {
			create = create.SetCorporationDba(vendorprofile.CorporationDba)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(vendorprofile.Description)
		}

		if websiteURI, exists := m.WebsiteURI(); exists {
			create = create.SetWebsiteURI(websiteURI)
		} else {
			create = create.SetWebsiteURI(vendorprofile.WebsiteURI)
		}

		if taxID, exists := m.TaxID(); exists {
			create = create.SetTaxID(taxID)
		} else {
			create = create.SetTaxID(vendorprofile.TaxID)
		}

		if taxIDType, exists := m.TaxIDType(); exists {
			create = create.SetTaxIDType(taxIDType)
		} else {
			create = create.SetTaxIDType(vendorprofile.TaxIDType)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfileMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofile, err := client.VendorProfile.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfileHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(vendorprofile.CreatedAt).
			SetUpdatedAt(vendorprofile.UpdatedAt).
			SetCreatedBy(vendorprofile.CreatedBy).
			SetUpdatedBy(vendorprofile.UpdatedBy).
			SetNillableDeletedAt(vendorprofile.DeletedAt).
			SetNillableDeletedBy(vendorprofile.DeletedBy).
			SetMappingID(vendorprofile.MappingID).
			SetTags(vendorprofile.Tags).
			SetOwnerID(vendorprofile.OwnerID).
			SetVendorID(vendorprofile.VendorID).
			SetName(vendorprofile.Name).
			SetCorporationType(vendorprofile.CorporationType).
			SetCorporationDba(vendorprofile.CorporationDba).
			SetDescription(vendorprofile.Description).
			SetWebsiteURI(vendorprofile.WebsiteURI).
			SetTaxID(vendorprofile.TaxID).
			SetTaxIDType(vendorprofile.TaxIDType).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfilePaymentPreferenceMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.VendorProfilePaymentPreferenceHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if vendorProfileID, exists := m.VendorProfileID(); exists {
		create = create.SetVendorProfileID(vendorProfileID)
	}

	if preferred, exists := m.Preferred(); exists {
		create = create.SetPreferred(preferred)
	}

	if method, exists := m.Method(); exists {
		create = create.SetMethod(method)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *VendorProfilePaymentPreferenceMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofilepaymentpreference, err := client.VendorProfilePaymentPreference.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfilePaymentPreferenceHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(vendorprofilepaymentpreference.MappingID)
		}

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(vendorprofilepaymentpreference.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(vendorprofilepaymentpreference.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(vendorprofilepaymentpreference.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(vendorprofilepaymentpreference.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(vendorprofilepaymentpreference.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(vendorprofilepaymentpreference.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(vendorprofilepaymentpreference.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(vendorprofilepaymentpreference.OwnerID)
		}

		if vendorProfileID, exists := m.VendorProfileID(); exists {
			create = create.SetVendorProfileID(vendorProfileID)
		} else {
			create = create.SetVendorProfileID(vendorprofilepaymentpreference.VendorProfileID)
		}

		if preferred, exists := m.Preferred(); exists {
			create = create.SetPreferred(preferred)
		} else {
			create = create.SetPreferred(vendorprofilepaymentpreference.Preferred)
		}

		if method, exists := m.Method(); exists {
			create = create.SetMethod(method)
		} else {
			create = create.SetMethod(vendorprofilepaymentpreference.Method)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfilePaymentPreferenceMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofilepaymentpreference, err := client.VendorProfilePaymentPreference.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfilePaymentPreferenceHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetMappingID(vendorprofilepaymentpreference.MappingID).
			SetCreatedAt(vendorprofilepaymentpreference.CreatedAt).
			SetUpdatedAt(vendorprofilepaymentpreference.UpdatedAt).
			SetCreatedBy(vendorprofilepaymentpreference.CreatedBy).
			SetUpdatedBy(vendorprofilepaymentpreference.UpdatedBy).
			SetNillableDeletedAt(vendorprofilepaymentpreference.DeletedAt).
			SetNillableDeletedBy(vendorprofilepaymentpreference.DeletedBy).
			SetTags(vendorprofilepaymentpreference.Tags).
			SetOwnerID(vendorprofilepaymentpreference.OwnerID).
			SetVendorProfileID(vendorprofilepaymentpreference.VendorProfileID).
			SetPreferred(vendorprofilepaymentpreference.Preferred).
			SetMethod(vendorprofilepaymentpreference.Method).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfilePhoneNumberMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.VendorProfilePhoneNumberHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if vendorProfileID, exists := m.VendorProfileID(); exists {
		create = create.SetVendorProfileID(vendorProfileID)
	}

	if phoneNumberID, exists := m.PhoneNumberID(); exists {
		create = create.SetPhoneNumberID(phoneNumberID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *VendorProfilePhoneNumberMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofilephonenumber, err := client.VendorProfilePhoneNumber.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfilePhoneNumberHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(vendorprofilephonenumber.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(vendorprofilephonenumber.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(vendorprofilephonenumber.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(vendorprofilephonenumber.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(vendorprofilephonenumber.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(vendorprofilephonenumber.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(vendorprofilephonenumber.DeletedBy)
		}

		if vendorProfileID, exists := m.VendorProfileID(); exists {
			create = create.SetVendorProfileID(vendorProfileID)
		} else {
			create = create.SetVendorProfileID(vendorprofilephonenumber.VendorProfileID)
		}

		if phoneNumberID, exists := m.PhoneNumberID(); exists {
			create = create.SetPhoneNumberID(phoneNumberID)
		} else {
			create = create.SetPhoneNumberID(vendorprofilephonenumber.PhoneNumberID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfilePhoneNumberMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofilephonenumber, err := client.VendorProfilePhoneNumber.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfilePhoneNumberHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(vendorprofilephonenumber.CreatedAt).
			SetUpdatedAt(vendorprofilephonenumber.UpdatedAt).
			SetCreatedBy(vendorprofilephonenumber.CreatedBy).
			SetUpdatedBy(vendorprofilephonenumber.UpdatedBy).
			SetMappingID(vendorprofilephonenumber.MappingID).
			SetNillableDeletedAt(vendorprofilephonenumber.DeletedAt).
			SetNillableDeletedBy(vendorprofilephonenumber.DeletedBy).
			SetVendorProfileID(vendorprofilephonenumber.VendorProfileID).
			SetPhoneNumberID(vendorprofilephonenumber.PhoneNumberID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfilePostalAddressMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.VendorProfilePostalAddressHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if postalAddressType, exists := m.PostalAddressType(); exists {
		create = create.SetPostalAddressType(postalAddressType)
	}

	if vendorProfileID, exists := m.VendorProfileID(); exists {
		create = create.SetVendorProfileID(vendorProfileID)
	}

	if postalAddressID, exists := m.PostalAddressID(); exists {
		create = create.SetPostalAddressID(postalAddressID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *VendorProfilePostalAddressMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofilepostaladdress, err := client.VendorProfilePostalAddress.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfilePostalAddressHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(vendorprofilepostaladdress.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(vendorprofilepostaladdress.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(vendorprofilepostaladdress.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(vendorprofilepostaladdress.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(vendorprofilepostaladdress.MappingID)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(vendorprofilepostaladdress.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(vendorprofilepostaladdress.DeletedBy)
		}

		if postalAddressType, exists := m.PostalAddressType(); exists {
			create = create.SetPostalAddressType(postalAddressType)
		} else {
			create = create.SetPostalAddressType(vendorprofilepostaladdress.PostalAddressType)
		}

		if vendorProfileID, exists := m.VendorProfileID(); exists {
			create = create.SetVendorProfileID(vendorProfileID)
		} else {
			create = create.SetVendorProfileID(vendorprofilepostaladdress.VendorProfileID)
		}

		if postalAddressID, exists := m.PostalAddressID(); exists {
			create = create.SetPostalAddressID(postalAddressID)
		} else {
			create = create.SetPostalAddressID(vendorprofilepostaladdress.PostalAddressID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *VendorProfilePostalAddressMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vendorprofilepostaladdress, err := client.VendorProfilePostalAddress.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VendorProfilePostalAddressHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(vendorprofilepostaladdress.CreatedAt).
			SetUpdatedAt(vendorprofilepostaladdress.UpdatedAt).
			SetCreatedBy(vendorprofilepostaladdress.CreatedBy).
			SetUpdatedBy(vendorprofilepostaladdress.UpdatedBy).
			SetMappingID(vendorprofilepostaladdress.MappingID).
			SetNillableDeletedAt(vendorprofilepostaladdress.DeletedAt).
			SetNillableDeletedBy(vendorprofilepostaladdress.DeletedBy).
			SetPostalAddressType(vendorprofilepostaladdress.PostalAddressType).
			SetVendorProfileID(vendorprofilepostaladdress.VendorProfileID).
			SetPostalAddressID(vendorprofilepostaladdress.PostalAddressID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *WebhookMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.WebhookHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if mappingID, exists := m.MappingID(); exists {
		create = create.SetMappingID(mappingID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetNillableDeletedAt(&deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetNillableDeletedBy(&deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if destinationURL, exists := m.DestinationURL(); exists {
		create = create.SetDestinationURL(destinationURL)
	}

	if enabled, exists := m.Enabled(); exists {
		create = create.SetEnabled(enabled)
	}

	if callback, exists := m.Callback(); exists {
		create = create.SetCallback(callback)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetExpiresAt(expiresAt)
	}

	if secret, exists := m.Secret(); exists {
		create = create.SetSecret(secret)
	}

	if failures, exists := m.Failures(); exists {
		create = create.SetFailures(failures)
	}

	if lastError, exists := m.LastError(); exists {
		create = create.SetLastError(lastError)
	}

	if lastResponse, exists := m.LastResponse(); exists {
		create = create.SetLastResponse(lastResponse)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *WebhookMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		webhook, err := client.Webhook.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WebhookHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(webhook.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(webhook.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(webhook.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(webhook.UpdatedBy)
		}

		if mappingID, exists := m.MappingID(); exists {
			create = create.SetMappingID(mappingID)
		} else {
			create = create.SetMappingID(webhook.MappingID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(webhook.Tags)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetNillableDeletedAt(&deletedAt)
		} else {
			create = create.SetNillableDeletedAt(webhook.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetNillableDeletedBy(&deletedBy)
		} else {
			create = create.SetNillableDeletedBy(webhook.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(webhook.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(webhook.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(webhook.Description)
		}

		if destinationURL, exists := m.DestinationURL(); exists {
			create = create.SetDestinationURL(destinationURL)
		} else {
			create = create.SetDestinationURL(webhook.DestinationURL)
		}

		if enabled, exists := m.Enabled(); exists {
			create = create.SetEnabled(enabled)
		} else {
			create = create.SetEnabled(webhook.Enabled)
		}

		if callback, exists := m.Callback(); exists {
			create = create.SetCallback(callback)
		} else {
			create = create.SetCallback(webhook.Callback)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetExpiresAt(expiresAt)
		} else {
			create = create.SetExpiresAt(webhook.ExpiresAt)
		}

		if secret, exists := m.Secret(); exists {
			create = create.SetSecret(secret)
		} else {
			create = create.SetSecret(webhook.Secret)
		}

		if failures, exists := m.Failures(); exists {
			create = create.SetFailures(failures)
		} else {
			create = create.SetFailures(webhook.Failures)
		}

		if lastError, exists := m.LastError(); exists {
			create = create.SetLastError(lastError)
		} else {
			create = create.SetLastError(webhook.LastError)
		}

		if lastResponse, exists := m.LastResponse(); exists {
			create = create.SetLastResponse(lastResponse)
		} else {
			create = create.SetLastResponse(webhook.LastResponse)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *WebhookMutation) CreateHistoryFromDelete(ctx context.Context) error {
	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		webhook, err := client.Webhook.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WebhookHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(webhook.CreatedAt).
			SetUpdatedAt(webhook.UpdatedAt).
			SetCreatedBy(webhook.CreatedBy).
			SetUpdatedBy(webhook.UpdatedBy).
			SetMappingID(webhook.MappingID).
			SetTags(webhook.Tags).
			SetNillableDeletedAt(webhook.DeletedAt).
			SetNillableDeletedBy(webhook.DeletedBy).
			SetOwnerID(webhook.OwnerID).
			SetName(webhook.Name).
			SetDescription(webhook.Description).
			SetDestinationURL(webhook.DestinationURL).
			SetEnabled(webhook.Enabled).
			SetCallback(webhook.Callback).
			SetExpiresAt(webhook.ExpiresAt).
			SetSecret(webhook.Secret).
			SetFailures(webhook.Failures).
			SetLastError(webhook.LastError).
			SetLastResponse(webhook.LastResponse).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}
