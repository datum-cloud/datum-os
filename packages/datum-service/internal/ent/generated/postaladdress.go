// Code generated by ent, DO NOT EDIT.

package generated

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/datum-cloud/datum-os/internal/ent/generated/organization"
	"github.com/datum-cloud/datum-os/internal/ent/generated/postaladdress"
)

// PostalAddress is the model entity for the PostalAddress schema.
type PostalAddress struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// UpdatedBy holds the value of the "updated_by" field.
	UpdatedBy string `json:"updated_by,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// DeletedBy holds the value of the "deleted_by" field.
	DeletedBy *string `json:"deleted_by,omitempty"`
	// MappingID holds the value of the "mapping_id" field.
	MappingID string `json:"mapping_id,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID string `json:"owner_id,omitempty"`
	// CLDR region code of the country/region of the address. See https://cldr.unicode.org/ for more details.
	RegionCode string `json:"region_code,omitempty"`
	// BCP-47 language code of the contents of this address (if known).
	LanguageCode *string `json:"language_code,omitempty"`
	// Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `json:"postal_code,omitempty"`
	// Additional, country-specific, sorting code. This is not used in most regions.
	SortingCode *string `json:"sorting_code,omitempty"`
	// Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture.
	AdministrativeArea *string `json:"administrative_area,omitempty"`
	// Locality of the address. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town.
	Locality *string `json:"locality,omitempty"`
	// Sublocality of the address. This is the neighborhood, district, or town.
	Sublocality *string `json:"sublocality,omitempty"`
	// Unstructured address lines describing the lower levels of an address.
	AddressLines []string `json:"address_lines,omitempty"`
	// Recipients of the address. This field may, under certain circumstances, contain multiline information. For example, it might contain 'care of' information.
	Recipients []string `json:"recipients,omitempty"`
	// Organization of the address.
	Organization *string `json:"organization,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the PostalAddressQuery when eager-loading is set.
	Edges                   PostalAddressEdges `json:"edges"`
	entity_postal_addresses *string
	selectValues            sql.SelectValues
}

// PostalAddressEdges holds the relations/edges for other nodes in the graph.
type PostalAddressEdges struct {
	// Owner holds the value of the owner edge.
	Owner *Organization `json:"owner,omitempty"`
	// Events holds the value of the events edge.
	Events []*Event `json:"events,omitempty"`
	// Profile holds the value of the profile edge.
	Profile []*VendorProfile `json:"profile,omitempty"`
	// VendorProfilePostalAddresses holds the value of the vendor_profile_postal_addresses edge.
	VendorProfilePostalAddresses []*VendorProfilePostalAddress `json:"vendor_profile_postal_addresses,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [4]bool
	// totalCount holds the count of the edges above.
	totalCount [4]map[string]int

	namedEvents                       map[string][]*Event
	namedProfile                      map[string][]*VendorProfile
	namedVendorProfilePostalAddresses map[string][]*VendorProfilePostalAddress
}

// OwnerOrErr returns the Owner value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PostalAddressEdges) OwnerOrErr() (*Organization, error) {
	if e.Owner != nil {
		return e.Owner, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: organization.Label}
	}
	return nil, &NotLoadedError{edge: "owner"}
}

// EventsOrErr returns the Events value or an error if the edge
// was not loaded in eager-loading.
func (e PostalAddressEdges) EventsOrErr() ([]*Event, error) {
	if e.loadedTypes[1] {
		return e.Events, nil
	}
	return nil, &NotLoadedError{edge: "events"}
}

// ProfileOrErr returns the Profile value or an error if the edge
// was not loaded in eager-loading.
func (e PostalAddressEdges) ProfileOrErr() ([]*VendorProfile, error) {
	if e.loadedTypes[2] {
		return e.Profile, nil
	}
	return nil, &NotLoadedError{edge: "profile"}
}

// VendorProfilePostalAddressesOrErr returns the VendorProfilePostalAddresses value or an error if the edge
// was not loaded in eager-loading.
func (e PostalAddressEdges) VendorProfilePostalAddressesOrErr() ([]*VendorProfilePostalAddress, error) {
	if e.loadedTypes[3] {
		return e.VendorProfilePostalAddresses, nil
	}
	return nil, &NotLoadedError{edge: "vendor_profile_postal_addresses"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*PostalAddress) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case postaladdress.FieldTags, postaladdress.FieldAddressLines, postaladdress.FieldRecipients:
			values[i] = new([]byte)
		case postaladdress.FieldID, postaladdress.FieldCreatedBy, postaladdress.FieldUpdatedBy, postaladdress.FieldDeletedBy, postaladdress.FieldMappingID, postaladdress.FieldOwnerID, postaladdress.FieldRegionCode, postaladdress.FieldLanguageCode, postaladdress.FieldPostalCode, postaladdress.FieldSortingCode, postaladdress.FieldAdministrativeArea, postaladdress.FieldLocality, postaladdress.FieldSublocality, postaladdress.FieldOrganization:
			values[i] = new(sql.NullString)
		case postaladdress.FieldCreatedAt, postaladdress.FieldUpdatedAt, postaladdress.FieldDeletedAt:
			values[i] = new(sql.NullTime)
		case postaladdress.ForeignKeys[0]: // entity_postal_addresses
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the PostalAddress fields.
func (pa *PostalAddress) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case postaladdress.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				pa.ID = value.String
			}
		case postaladdress.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				pa.CreatedAt = value.Time
			}
		case postaladdress.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				pa.UpdatedAt = value.Time
			}
		case postaladdress.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				pa.CreatedBy = value.String
			}
		case postaladdress.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				pa.UpdatedBy = value.String
			}
		case postaladdress.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				pa.DeletedAt = new(time.Time)
				*pa.DeletedAt = value.Time
			}
		case postaladdress.FieldDeletedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_by", values[i])
			} else if value.Valid {
				pa.DeletedBy = new(string)
				*pa.DeletedBy = value.String
			}
		case postaladdress.FieldMappingID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mapping_id", values[i])
			} else if value.Valid {
				pa.MappingID = value.String
			}
		case postaladdress.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &pa.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case postaladdress.FieldOwnerID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field owner_id", values[i])
			} else if value.Valid {
				pa.OwnerID = value.String
			}
		case postaladdress.FieldRegionCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region_code", values[i])
			} else if value.Valid {
				pa.RegionCode = value.String
			}
		case postaladdress.FieldLanguageCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field language_code", values[i])
			} else if value.Valid {
				pa.LanguageCode = new(string)
				*pa.LanguageCode = value.String
			}
		case postaladdress.FieldPostalCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field postal_code", values[i])
			} else if value.Valid {
				pa.PostalCode = new(string)
				*pa.PostalCode = value.String
			}
		case postaladdress.FieldSortingCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sorting_code", values[i])
			} else if value.Valid {
				pa.SortingCode = new(string)
				*pa.SortingCode = value.String
			}
		case postaladdress.FieldAdministrativeArea:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field administrative_area", values[i])
			} else if value.Valid {
				pa.AdministrativeArea = new(string)
				*pa.AdministrativeArea = value.String
			}
		case postaladdress.FieldLocality:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field locality", values[i])
			} else if value.Valid {
				pa.Locality = new(string)
				*pa.Locality = value.String
			}
		case postaladdress.FieldSublocality:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sublocality", values[i])
			} else if value.Valid {
				pa.Sublocality = new(string)
				*pa.Sublocality = value.String
			}
		case postaladdress.FieldAddressLines:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field address_lines", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &pa.AddressLines); err != nil {
					return fmt.Errorf("unmarshal field address_lines: %w", err)
				}
			}
		case postaladdress.FieldRecipients:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field recipients", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &pa.Recipients); err != nil {
					return fmt.Errorf("unmarshal field recipients: %w", err)
				}
			}
		case postaladdress.FieldOrganization:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field organization", values[i])
			} else if value.Valid {
				pa.Organization = new(string)
				*pa.Organization = value.String
			}
		case postaladdress.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field entity_postal_addresses", values[i])
			} else if value.Valid {
				pa.entity_postal_addresses = new(string)
				*pa.entity_postal_addresses = value.String
			}
		default:
			pa.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the PostalAddress.
// This includes values selected through modifiers, order, etc.
func (pa *PostalAddress) Value(name string) (ent.Value, error) {
	return pa.selectValues.Get(name)
}

// QueryOwner queries the "owner" edge of the PostalAddress entity.
func (pa *PostalAddress) QueryOwner() *OrganizationQuery {
	return NewPostalAddressClient(pa.config).QueryOwner(pa)
}

// QueryEvents queries the "events" edge of the PostalAddress entity.
func (pa *PostalAddress) QueryEvents() *EventQuery {
	return NewPostalAddressClient(pa.config).QueryEvents(pa)
}

// QueryProfile queries the "profile" edge of the PostalAddress entity.
func (pa *PostalAddress) QueryProfile() *VendorProfileQuery {
	return NewPostalAddressClient(pa.config).QueryProfile(pa)
}

// QueryVendorProfilePostalAddresses queries the "vendor_profile_postal_addresses" edge of the PostalAddress entity.
func (pa *PostalAddress) QueryVendorProfilePostalAddresses() *VendorProfilePostalAddressQuery {
	return NewPostalAddressClient(pa.config).QueryVendorProfilePostalAddresses(pa)
}

// Update returns a builder for updating this PostalAddress.
// Note that you need to call PostalAddress.Unwrap() before calling this method if this PostalAddress
// was returned from a transaction, and the transaction was committed or rolled back.
func (pa *PostalAddress) Update() *PostalAddressUpdateOne {
	return NewPostalAddressClient(pa.config).UpdateOne(pa)
}

// Unwrap unwraps the PostalAddress entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pa *PostalAddress) Unwrap() *PostalAddress {
	_tx, ok := pa.config.driver.(*txDriver)
	if !ok {
		panic("generated: PostalAddress is not a transactional entity")
	}
	pa.config.driver = _tx.drv
	return pa
}

// String implements the fmt.Stringer.
func (pa *PostalAddress) String() string {
	var builder strings.Builder
	builder.WriteString("PostalAddress(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pa.ID))
	builder.WriteString("created_at=")
	builder.WriteString(pa.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(pa.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(pa.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(pa.UpdatedBy)
	builder.WriteString(", ")
	if v := pa.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := pa.DeletedBy; v != nil {
		builder.WriteString("deleted_by=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("mapping_id=")
	builder.WriteString(pa.MappingID)
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", pa.Tags))
	builder.WriteString(", ")
	builder.WriteString("owner_id=")
	builder.WriteString(pa.OwnerID)
	builder.WriteString(", ")
	builder.WriteString("region_code=")
	builder.WriteString(pa.RegionCode)
	builder.WriteString(", ")
	if v := pa.LanguageCode; v != nil {
		builder.WriteString("language_code=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pa.PostalCode; v != nil {
		builder.WriteString("postal_code=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pa.SortingCode; v != nil {
		builder.WriteString("sorting_code=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pa.AdministrativeArea; v != nil {
		builder.WriteString("administrative_area=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pa.Locality; v != nil {
		builder.WriteString("locality=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pa.Sublocality; v != nil {
		builder.WriteString("sublocality=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("address_lines=")
	builder.WriteString(fmt.Sprintf("%v", pa.AddressLines))
	builder.WriteString(", ")
	builder.WriteString("recipients=")
	builder.WriteString(fmt.Sprintf("%v", pa.Recipients))
	builder.WriteString(", ")
	if v := pa.Organization; v != nil {
		builder.WriteString("organization=")
		builder.WriteString(*v)
	}
	builder.WriteByte(')')
	return builder.String()
}

// NamedEvents returns the Events named value or an error if the edge was not
// loaded in eager-loading with this name.
func (pa *PostalAddress) NamedEvents(name string) ([]*Event, error) {
	if pa.Edges.namedEvents == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := pa.Edges.namedEvents[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (pa *PostalAddress) appendNamedEvents(name string, edges ...*Event) {
	if pa.Edges.namedEvents == nil {
		pa.Edges.namedEvents = make(map[string][]*Event)
	}
	if len(edges) == 0 {
		pa.Edges.namedEvents[name] = []*Event{}
	} else {
		pa.Edges.namedEvents[name] = append(pa.Edges.namedEvents[name], edges...)
	}
}

// NamedProfile returns the Profile named value or an error if the edge was not
// loaded in eager-loading with this name.
func (pa *PostalAddress) NamedProfile(name string) ([]*VendorProfile, error) {
	if pa.Edges.namedProfile == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := pa.Edges.namedProfile[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (pa *PostalAddress) appendNamedProfile(name string, edges ...*VendorProfile) {
	if pa.Edges.namedProfile == nil {
		pa.Edges.namedProfile = make(map[string][]*VendorProfile)
	}
	if len(edges) == 0 {
		pa.Edges.namedProfile[name] = []*VendorProfile{}
	} else {
		pa.Edges.namedProfile[name] = append(pa.Edges.namedProfile[name], edges...)
	}
}

// NamedVendorProfilePostalAddresses returns the VendorProfilePostalAddresses named value or an error if the edge was not
// loaded in eager-loading with this name.
func (pa *PostalAddress) NamedVendorProfilePostalAddresses(name string) ([]*VendorProfilePostalAddress, error) {
	if pa.Edges.namedVendorProfilePostalAddresses == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := pa.Edges.namedVendorProfilePostalAddresses[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (pa *PostalAddress) appendNamedVendorProfilePostalAddresses(name string, edges ...*VendorProfilePostalAddress) {
	if pa.Edges.namedVendorProfilePostalAddresses == nil {
		pa.Edges.namedVendorProfilePostalAddresses = make(map[string][]*VendorProfilePostalAddress)
	}
	if len(edges) == 0 {
		pa.Edges.namedVendorProfilePostalAddresses[name] = []*VendorProfilePostalAddress{}
	} else {
		pa.Edges.namedVendorProfilePostalAddresses[name] = append(pa.Edges.namedVendorProfilePostalAddresses[name], edges...)
	}
}

// PostalAddresses is a parsable slice of PostalAddress.
type PostalAddresses []*PostalAddress
